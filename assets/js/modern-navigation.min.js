/**
 * ModernNavigation (improved, integrated with centralized language system)
 * - Keeps most original features
 * - Integrates with window.languageManager where available for centralized language/history mapping
 * - Distinguishes local/dev hosts vs production: on local/dev do NOT add language prefix to generated URLs,
 *   and disable aggressive candidate probing. On production everything runs fully.
 * - Emits events to centralize responsibilities:
 *     * 'modernNav:navigate-intent' (detail: { destination, candidates, originalEvent })
 *     * uses languageChange and storage events for language updates
 * - Uses a per-instance isLocalDev flag computed once at init for consistent behavior
 *
 * Important responsibilities separation:
 * - Navigation UI: render nav, update active state, animate icons
 * - Navigation routing resolution: attempt candidate probing (only on production)
 * - Language/history mapping: delegated to window.languageManager when present (recordLanguageForPath,
 *   recordLanguageForCurrentEntry, getPredictedLangForPath)
 *
 * Note: this file replaces/modifies behavior from upstream to ensure consistent dev vs prod behavior.
 */

/* --- [BEGIN: Wave Effect Loader] --- */
(function(){
  // ตรวจสอบว่ามี wave-effect.min.js อยู่แล้วหรือยัง ถ้ายังไม่มีให้เพิ่มเข้าไป
  var waveScriptSrc = "https://marcumat-js.pages.dev/dist/wave-effect.js";
  if (!document.querySelector('script[src="' + waveScriptSrc + '"]')) {
    var script = document.createElement('script');
    script.src = waveScriptSrc;
    script.async = true;
    document.head.appendChild(script);
  }
})();
/* --- [END: Wave Effect Loader] --- */

class ModernNavigation {
  constructor(config = {}) {
    this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
    this.configPath = config.configPath || '/assets/json/buttons.min.json';
    this.activeClass = config.activeClass || 'active-1';
    this.navItemSelector = config.navItemSelector || '.nav-item';
    this.defaultButtonClass = config.defaultButtonClass || 'default-button';

    // left rail sizes (strings with units)
    this.leftRailWidth = config.leftRailWidth || '88px';
    this.leftRailCollapsedWidth = config.leftRailCollapsedWidth || '72px';

    this.defaultLang = 'en';
    this.currentLang = localStorage.getItem('selectedLang') || this.defaultLang;

    this._initialized = false;
    this._config = null;
    this._navEl = null;

    // state
    this._isTouching = false;
    this._navVisible = true;
    this._lastScrollY = window.scrollY;
    this._rafId = null;
    this.SHOW_THRESHOLD = 40;

    // ✅ External control state (can override scroll behavior)
    this._externalHideRequested = false;
    this._autoScrollSyncEnabled = true;

    // saved original localStorage.setItem for restoration
    this._originalSetItem = localStorage.setItem.bind(localStorage);

    // ✅ Smart URL Matcher: supported language codes
    this._supportedLangCodes = config.supportedLangCodes || [
      'th', 'en', 'ja', 'ko', 'zh', 'fr', 'de', 'es', 'it', 'pt', 'ru', 'ar', 'vi', 'id', 'ms', 'tl'
    ];

    // Option: force adding language prefix when known (effective only on production)
    this.forceLangPrefix = (typeof config.forceLangPrefix !== 'undefined') ? !!config.forceLangPrefix : true;

    // compute local/dev once and store
    this.isLocalDev = ModernNavigation._isLocalDev();

    // effective flag that respects dev/production separation
    this._effectiveForceLangPrefix = this.forceLangPrefix && !this.isLocalDev;

    // bound handlers to enable removal and avoid duplicates
    this._resizeHandler = this._debounce(this._applyScreenBehavior.bind(this), 120);
    this._orientationHandler = this._applyScreenBehavior.bind(this);
    this._scrollHandler = this._onScrollForActiveState.bind(this);
    this._storageHandler = this._onStorageEvent.bind(this);
    this._onUltraScrollNavBound = this._onUltraScrollNav.bind(this);
    this._onTouchStartBound = this._onTouchStart.bind(this);
    this._onTouchEndBound = this._onTouchEnd.bind(this);
    this._onNavClickBound = this._onNavClick.bind(this);
    this._onExternalCommandBound = this._onExternalCommand.bind(this);
  }

  /* public init */
  async init() {
    if (this._initialized) return;
    try {
      ModernNavigation._preconnect(this.configPath);
      await this._loadCSS();
      this._config = await this._fetchConfig();
      const fragment = this._createNavigationItemsFragment();
      this._injectNavigation(fragment);
      this._navEl = document.querySelector('.bottom-nav');
      if (!this._navEl) throw new Error('navigation element not created');

      // initial GPU hint
      this._navEl.style.willChange = 'transform';

      this._bindBaseListeners();
      this._updateActiveState(); // initial active
      this._applyScreenBehavior(); // mount/unmount according to screen
      this._initialized = true;
    } catch (err) {
      this._cleanup();
      console.error('ModernNavigation init error:', err);
      throw err;
    }
  }

  /* --- static helpers --- */
  static _preconnect(configPath){
    try {
      const url = new URL(configPath, location.origin);
      if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)){
        const l = document.createElement('link');
        l.rel = 'preconnect';
        l.href = url.origin;
        document.head.appendChild(l);
      }
    } catch (_){}
  }

  /* helper to detect local/dev hosts to avoid aggressive candidate fetches */
  static _isLocalDev() {
    try {
      const host = location.hostname || '';
      if (!host) return false;
      if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return true;
      if (host.endsWith('.local')) return true;
      if (location.port && ['3000','5173','7700','8080','3001'].includes(String(location.port))) return true;
      return false;
    } catch (e) { return false; }
  }

  /* --- CSS / config loading --- */
  async _loadCSS(){
    if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = this.cssPath;
    document.head.appendChild(link);
    await new Promise(resolve => { link.onload = resolve; link.onerror = resolve; });
  }

  async _fetchConfig(){
    try {
      const res = await fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      // fallback to empty navigation
      return { navigation: [] };
    }
  }

  /* --- Smart URL Matcher helpers --- */
  _isLangCode(segment) {
    return this._supportedLangCodes.includes(segment.toLowerCase());
  }

  _parseUrlPath(path) {
    const normalizedPath = (path || '/').replace(/\/+$/, '') || '/';
    const segments = normalizedPath.split('/').filter(s => s.length > 0);
    if (segments.length > 0 && this._isLangCode(segments[0])) {
      const lang = segments[0].toLowerCase();
      const cleanSegments = segments.slice(1);
      const cleanPath = cleanSegments.length > 0 ? '/' + cleanSegments.join('/') : '/';
      return {
        lang: lang,
        cleanPath: cleanPath,
        originalPath: normalizedPath,
        hasLangPrefix: true
      };
    }
    return {
      lang: null,
      cleanPath: normalizedPath,
      originalPath: normalizedPath,
      hasLangPrefix: false
    };
  }

  _isNavLinkActive(navLink, currentPath) {
    const normalizedNavLink = (navLink || '').replace(/\/+$/, '') || '/';
    const parsed = this._parseUrlPath(currentPath);
    const cleanCurrentPath = parsed.cleanPath;

    if (normalizedNavLink === '/' || normalizedNavLink === '/index.html') {
      const isHome = cleanCurrentPath === '/' || cleanCurrentPath === '/index.html' || currentPath === '/' || currentPath === '/index.html' || (parsed.hasLangPrefix && cleanCurrentPath === '/');
      return isHome;
    }

    if (cleanCurrentPath === normalizedNavLink) return true;

    const navLinkWithSlash = normalizedNavLink.endsWith('/') ? normalizedNavLink : normalizedNavLink + '/';
    const currentWithSlash = cleanCurrentPath.endsWith('/') ? cleanCurrentPath : cleanCurrentPath + '/';
    if (currentWithSlash.startsWith(navLinkWithSlash)) return true;

    if (cleanCurrentPath === normalizedNavLink) return true;
    return false;
  }

  /**
   * Generate navigation URL.
   * - On local/dev: do NOT add language prefix (respect dev workflow).
   * - On production: if effectiveForceLangPrefix is true, add preferred language prefix.
   */
  _generateNavUrl(baseUrl) {
    const raw = baseUrl || '/';
    if (raw.startsWith('http') || raw.startsWith('//') || raw.startsWith('#')) return raw;
    const normalizedBase = raw.startsWith('/') ? raw : '/' + raw;

    // If baseUrl already has language prefix, return as-is
    const baseSegments = normalizedBase.split('/').filter(s => s.length > 0);
    if (baseSegments.length > 0 && this._isLangCode(baseSegments[0])) {
      return normalizedBase;
    }

    // If running on local/dev, do not prefix
    if (this.isLocalDev) {
      return normalizedBase;
    }

    // Determine preferred lang: prefer lang in URL (if any), then currentLang, then default
    const parsedCurrent = this._parseUrlPath(window.location.pathname);
    const preferredLang = parsedCurrent.lang || this.currentLang || this.defaultLang;

    if (this._effectiveForceLangPrefix && preferredLang) {
      return '/' + preferredLang + (normalizedBase === '/' ? '/' : normalizedBase);
    }

    return normalizedBase;
  }

  /* --- Build candidate URLs for aggressive navigation (production only) --- */
  _buildCandidatesForDestination(baseUrl) {
    const base = baseUrl.startsWith('/') ? baseUrl : '/' + baseUrl;
    const parsedCurrent = this._parseUrlPath(window.location.pathname);
    const candidates = [];
    const tried = new Set();

    // languages to try: url lang, currentLang, default
    const langsToTry = [];
    if (parsedCurrent.lang) langsToTry.push(parsedCurrent.lang);
    if (this.currentLang && !langsToTry.includes(this.currentLang)) langsToTry.push(this.currentLang);
    if (this.defaultLang && !langsToTry.includes(this.defaultLang)) langsToTry.push(this.defaultLang);
    const uniqLangs = Array.from(new Set(langsToTry));

    uniqLangs.forEach(lang => {
      const pref = '/' + lang;
      const c1 = pref + base;
      const c2 = c1.endsWith('/') ? c1 + 'index.html' : c1 + '/index.html';
      candidates.push(c1, c2);
      if (!c1.endsWith('/')) candidates.push(c1 + '/');
    });

    candidates.push(base);
    candidates.push(base.endsWith('/') ? base + 'index.html' : base + '/index.html');
    if (!base.endsWith('/')) candidates.push(base + '/');

    if (base === '/' || base === '/index.html') {
      uniqLangs.forEach(lang => {
        candidates.push('/' + lang + '/home/', '/' + lang + '/home/index.html');
      });
      candidates.push('/home/', '/home/index.html');
    }

    const out = [];
    for (const c of candidates) {
      if (!tried.has(c)) {
        tried.add(c);
        out.push(c);
      }
    }
    return out;
  }

  /**
   * Try candidate navigation only on production (isLocalDev === false).
   * If language detected in candidate, delegate to languageManager to record mapping (central responsibility).
   */
  async _tryNavigateCandidates(destinationPath, originalEvent) {
    if (this.isLocalDev) return false; // do not do aggressive probing on dev

    if (!destinationPath || /^(mailto:|tel:|javascript:|#)/i.test(destinationPath)) return false;
    try {
      const candidates = this._buildCandidatesForDestination(destinationPath);

      // allow external systems to observe/override candidate list before we fetch
      try {
        const ev = new CustomEvent('modernNav:navigate-intent', { detail: { destination: destinationPath, candidates, originalEvent } });
        window.dispatchEvent(ev);
      } catch (e){}

      for (const c of candidates) {
        try {
          const resp = await fetch(c, { method: 'HEAD', cache: 'no-store', credentials: 'same-origin' });
          if (resp && resp.ok) {
            const p = this._parseUrlPath(c);
            const foundLang = p && p.hasLangPrefix ? p.lang : null;

            // CENTRAL: delegate language recording to languageManager if available
            try {
              if (foundLang) {
                try { localStorage.setItem('selectedLang', foundLang); } catch(e){}
                if (window.languageManager && typeof window.languageManager.updatePageLanguage === 'function') {
                  // Trigger language update non-blocking; languageManager will handle recording of history-entry mapping
                  try {
                    if ((window.languageManager.selectedLang || '') !== foundLang) {
                      window.languageManager.updatePageLanguage(foundLang).catch(()=>{});
                    } else {
                      // ensure record of current entry in languageManager
                      if (typeof window.languageManager.recordLanguageForCurrentEntry === 'function') {
                        try { window.languageManager.recordLanguageForCurrentEntry(foundLang); } catch(e){}
                      }
                    }
                  } catch (e){}
                } else {
                  // fallback: write to session map if languageManager not present
                  try {
                    const key = (new URL(c, location.origin)).pathname + ((new URL(c, location.origin)).search || '');
                    const rawMap = sessionStorage.getItem('fv-nav-lang-map') || '{}';
                    const map = JSON.parse(rawMap || '{}');
                    map[key] = { lang: foundLang, ts: Date.now(), evidence: 'nav-candidate' };
                    sessionStorage.setItem('fv-nav-lang-map', JSON.stringify(map));
                  } catch (e){}
                }
              } // end foundLang
            } catch (e){}

            // Preserve search/hash from original link element if present
            const urlObj = new URL(c, location.origin);
            try {
              const linkEl = originalEvent && originalEvent.target && originalEvent.target.closest ? originalEvent.target.closest('a[href]') : null;
              if (linkEl) {
                const raw = linkEl.getAttribute('href') || '';
                if (raw) {
                  const resolved = new URL(raw, location.origin);
                  if (resolved.search) urlObj.search = resolved.search;
                  if (resolved.hash) urlObj.hash = resolved.hash;
                }
              }
            } catch (e){}

            const finalUrl = urlObj.toString();
            try {
              window.location.assign(finalUrl);
            } catch (e) {
              try { location.href = finalUrl; } catch(e) {}
            }
            return true;
          }
        } catch (e) {
          // try next candidate
        }
      }
    } catch (e) {
      // nothing
    }
    return false;
  }

  /* --- build nav DOM --- */
  _createNavigationItemsFragment(){
    const fragment = document.createDocumentFragment();
    const config = this._config?.navigation || [];
    const lang = this.currentLang || this.defaultLang;

    for (let i = 0; i < config.length; i++){
      const item = config[i];
      const link = document.createElement('a');
      link.className = `nav-item ${item.customClass || this.defaultButtonClass}`;

      const baseUrl = item.go_url || item.url || '#';
      // Use generator which respects local/dev separation
      link.href = this._generateNavUrl(baseUrl);

      link.setAttribute('role', 'menuitem');

      if (item.url) link.dataset.link = item.url;
      if (item.go_url) link.dataset.goUrl = item.go_url;

      link.dataset.isExternal = (baseUrl.startsWith('http') || baseUrl.startsWith('//')) ? 'true' : 'false';

      link.setAttribute('wave-delegate', '.svg-wrapper');

      if (item.icon){
        const tmp = document.createElement('div');
        tmp.innerHTML = item.icon;
        const wrapper = document.createElement('span');
        wrapper.className = 'svg-wrapper';
        wrapper.setAttribute('wave', '');
        while (tmp.firstChild) wrapper.appendChild(tmp.firstChild);
        link.appendChild(wrapper);
      }
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
      link.appendChild(label);
      fragment.appendChild(link);
    }
    return fragment;
  }

  _injectNavigation(fragment){
    if (document.querySelector('.bottom-nav')) return;
    const nav = document.createElement('div');
    nav.className = 'bottom-nav';
    nav.setAttribute('role', 'navigation');
    nav.appendChild(fragment);
    document.body.insertBefore(nav, document.body.firstChild);
  }

  /* --- listeners / lifecycle --- */
  _bindBaseListeners(){
    if (!this._navEl) return;
    this._navEl.addEventListener('click', this._onNavClickBound, { passive: false });
    window.addEventListener('scroll', this._scrollHandler, { passive: true });
    window.addEventListener('storage', this._storageHandler);
    window.addEventListener('modernNavCommand', this._onExternalCommandBound);

    // SPA/popstate handling: only force reload on mismatch in production
    window.addEventListener('popstate', (ev) => {
      try {
        const parsed = this._parseUrlPath(window.location.pathname);
        const langInUrl = parsed.lang;
        const state = ev.state || {};
        const stateVersion = state && state.langVersion ? Number(state.langVersion) : null;
        const storedVersion = (function(){ try { return Number(localStorage.getItem('langVersion')||0); } catch(e){return 0;} })();
        const current = this.currentLang || this.defaultLang;
        if ((stateVersion !== null && stateVersion !== storedVersion) || (langInUrl && langInUrl !== current)) {
          if (!this.isLocalDev) {
            try { window.location.reload(); return; } catch(e){}
          }
        }
      } catch (e) {}
      this._updateActiveState();
    });

    // override localStorage.setItem to catch same-window changes
    const self = this;
    localStorage.setItem = function(key, value){
      self._originalSetItem(key, value);
      if (key === 'selectedLang') self._onSelectedLangChange(value);
    };

    // languageChange custom event
    window.addEventListener('languageChange', (e) => {
      if (e?.detail?.language) {
        this._onSelectedLangChange(e.detail.language);
        // update URLs only on production
        if (!this.isLocalDev) this._updateAllNavUrls();
      }
    });
  }

  _unbindBaseListeners(){
    if (!this._navEl) return;
    this._navEl.removeEventListener('click', this._onNavClickBound, { passive: false });
    window.removeEventListener('scroll', this._scrollHandler, { passive: true });
    window.removeEventListener('storage', this._storageHandler, { passive: true });
    window.removeEventListener('popstate', () => {});
    window.removeEventListener('languageChange', () => {});
    window.removeEventListener('modernNavCommand', this._onExternalCommandBound);
    try { localStorage.setItem = this._originalSetItem; } catch(e) {}
  }

  /* --- click handling --- */
  _onNavClick(event){
    const item = event.target.closest(this.navItemSelector);
    if (!item) return;

    const isExternal = item.dataset.isExternal === 'true';
    if (isExternal) {
      return; // do not intercept external links
    }

    const targetLink = item.dataset.link;
    const goLink = item.dataset.goUrl;
    const destination = goLink || targetLink;
    if (!destination) return;

    if (item.classList.contains(this.activeClass)) {
      event.preventDefault();
      return;
    }

    const currentPath = window.location.pathname;
    if (this._isNavLinkActive(destination, currentPath)) {
      event.preventDefault();
      return;
    }

    // Central pre-navigation recording: tell languageManager about intended navigation
    try {
      const preferredLang = (!this.isLocalDev && (this.currentLang || null)) || null;
      if (window.languageManager && typeof window.languageManager.recordLanguageForPath === 'function' && preferredLang) {
        try { window.languageManager.recordLanguageForPath(destination, preferredLang); } catch(e){}
      } else {
        // fallback: write entry to session map (only on production)
        if (!this.isLocalDev) {
          try {
            const tmp = new URL(destination, location.origin);
            const key = tmp.pathname + (tmp.search || '');
            const rawMap = sessionStorage.getItem('fv-nav-lang-map') || '{}';
            const map = JSON.parse(rawMap || '{}');
            map[key] = { lang: preferredLang, ts: Date.now(), evidence: 'nav-intent' };
            sessionStorage.setItem('fv-nav-lang-map', JSON.stringify(map));
          } catch(e){}
        }
      }
    } catch (e){}

    event.preventDefault();

    (async () => {
      // Try candidates only on production; local/dev will jump directly to generated href
      let did = false;
      try {
        did = await this._tryNavigateCandidates(destination, event);
      } catch (e) { did = false; }
      if (!did) {
        try {
          const linkEl = event.target.closest('a[href]');
          if (linkEl) {
            // on local/dev generated href will be unprefixed
            window.location.assign(linkEl.href);
          } else {
            window.location.assign(destination);
          }
        } catch (e) {
          try { location.href = destination; } catch (e2) {}
        }
      }
    })();
  }

  /* --- active state updates (rAF-friendly) --- */
  _onScrollForActiveState(){
    if (this._rafId == null){
      this._rafId = window.requestAnimationFrame(() => {
        this._updateActiveState();
        this._rafId = null;
      });
    }
  }

  _updateActiveState(){
    if (!this._navEl) return;
    const currentPath = window.location.pathname;
    const items = this._navEl.querySelectorAll(this.navItemSelector);

    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const navLink = it.dataset.link || it.dataset.goUrl || '';
      const shouldBeActive = this._isNavLinkActive(navLink, currentPath);
      const wasActive = it.classList.contains(this.activeClass);
      it.classList.toggle(this.activeClass, shouldBeActive);

      const wrapper = it.querySelector('.svg-wrapper');
      if (!wrapper) continue;

      if (shouldBeActive && !wasActive) {
        wrapper.classList.remove('animate');
        void wrapper.offsetWidth;
        wrapper.classList.add('animate');
      }
    }
  }

  /* --- update all nav URLs when language changes (production only) --- */
  _updateAllNavUrls(){
    if (!this._navEl) return;
    if (this.isLocalDev) return; // do not modify URLs on dev hosts
    const items = this._navEl.querySelectorAll(this.navItemSelector);

    for (let i = 0; i < items.length; i++){
      const item = items[i];
      const baseUrl = item.dataset.goUrl || item.dataset.link;
      if (!baseUrl) continue;
      if (item.dataset.isExternal === 'true') continue;
      const newUrl = this._generateNavUrl(baseUrl);
      item.href = newUrl;
    }
  }

  /* --- language / label updates --- */
  _onSelectedLangChange(val){
    const newLang = val || this.defaultLang;
    if (this.currentLang === newLang) return;
    this.currentLang = newLang;
    this._updateLabels(this.currentLang);
    if (!this.isLocalDev) this._updateAllNavUrls();
    this._updateActiveState();
  }

  _updateLabels(lang){
    if (!this._navEl || !this._config?.navigation) return;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const link = it.dataset.link;
      const cfg = this._config.navigation.find(n => n.url === link || n.go_url === link);
      if (cfg){
        const label = it.querySelector('.label');
        if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
      }
    }
  }

  _onStorageEvent(e){
    if (e.key === 'selectedLang') this._onSelectedLangChange(e.newValue);
  }

  /* --- External hide/show command handler --- */
  _onExternalCommand(event){
    const cmd = event?.detail?.command;
    const reason = event?.detail?.reason || 'unknown';
    if (cmd === 'hide') {
      this.hideNav(reason);
    } else if (cmd === 'show' || cmd === 'restore') {
      this.showNav(reason);
    } else if (cmd === 'toggle') {
      if (this._externalHideRequested || !this._navVisible) {
        this.showNav(reason);
      } else {
        this.hideNav(reason);
      }
    }
  }

  /* --- Public API: hide/show navigation --- */
  hideNav(reason = 'external') {
    if (!this._navEl) return;
    this._externalHideRequested = true;
    this._autoScrollSyncEnabled = false;
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navVisible = false;
    console.log(`[ModernNav] Navigation hidden (${reason})`);
    this._dispatchNavStateEvent('hidden', reason);
  }

  showNav(reason = 'external') {
    if (!this._navEl) return;
    this._externalHideRequested = false;
    this._autoScrollSyncEnabled = true;
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navVisible = true;
    console.log(`[ModernNav] Navigation shown (${reason})`);
    this._dispatchNavStateEvent('shown', reason);
  }

  toggleNav(reason = 'external') {
    if (this._externalHideRequested || !this._navVisible) {
      this.showNav(reason);
    } else {
      this.hideNav(reason);
    }
  }

  isNavVisible() {
    return this._navVisible && !this._externalHideRequested;
  }

  _dispatchNavStateEvent(state, reason) {
    const event = new CustomEvent('modernNavStateChanged', {
      detail: { state, reason, visible: this._navVisible }
    });
    window.dispatchEvent(event);
  }

  /* --- screen behavior: mount/unmount left-rail and mobile scroll sync --- */
  _isMobileScreen(){
    return window.innerWidth < 768;
  }

  _applyScreenBehavior(){
    const isMobile = this._isMobileScreen();
    if (this._navEl) this._navEl.classList.toggle('vertical', !isMobile);
    if (isMobile){
      this._unmountLeftRailIfMounted();
      this._enableScrollNavSync();
    } else {
      this._mountLeftRailIfNeeded();
      this._disableScrollNavSync();
    }
  }

  _mountLeftRailIfNeeded() {
    if (!this._navEl) return;
    if (document.body.classList.contains('has-left-rail')) return;

    const nav = this._navEl;
    const siteMain = document.createElement('div');
    siteMain.className = 'site-main';

    const nodes = Array.from(document.body.childNodes);
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node === nav) continue;
      siteMain.appendChild(node);
    }
    document.body.appendChild(siteMain);
    document.body.classList.add('has-left-rail');

    document.documentElement.style.setProperty('--left-rail-width', this.leftRailWidth);
    document.documentElement.style.setProperty('--left-rail-collapsed-width', this.leftRailCollapsedWidth);

    nav.style.position = 'fixed';
    nav.style.top = '0';
    nav.style.left = '0';
    nav.style.transform = 'none';
    nav.style.zIndex = '1000';
    nav.style.height = '100vh';
    nav.style.overflow = 'auto';

    siteMain.style.marginLeft = this.leftRailWidth;
  }

  _unmountLeftRailIfMounted(){
    if (!this._navEl) return;
    if (!document.body.classList.contains('has-left-rail')) return;
    const nav = this._navEl;
    const siteMain = document.querySelector('.site-main');
    if (siteMain){
      const children = Array.from(siteMain.childNodes);
      for (let i = 0; i < children.length; i++) {
        document.body.insertBefore(children[i], siteMain);
      }
      if (siteMain.parentNode) siteMain.parentNode.removeChild(siteMain);
    }
    document.body.classList.remove('has-left-rail');
    document.documentElement.style.removeProperty('--left-rail-width');
    document.documentElement.style.removeProperty('--left-rail-collapsed-width');

    nav.style.position = '';
    nav.style.top = '';
    nav.style.height = '';
    nav.style.left = '';
    nav.style.transform = '';
    nav.style.zIndex = '16000';
    nav.style.overflow = '';

    const bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach((el) => {
      if (el.style && el.style.marginLeft === this.leftRailWidth) {
        el.style.marginLeft = '';
      }
    });
  }

  /* --- mobile scroll sync (hide-on-scroll) --- */
  _enableScrollNavSync(){
    if (this._navScrollSyncEnabled) return;
    window.addEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.addEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.addEventListener('touchend', this._onTouchEndBound, { passive: true });
    if (this._navEl && !this._externalHideRequested){
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = true;
  }

  _disableScrollNavSync(){
    if (!this._navScrollSyncEnabled) return;
    window.removeEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.removeEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.removeEventListener('touchend', this._onTouchEndBound, { passive: true });
    if (this._navEl && !this._externalHideRequested){
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = false;
  }

  _onTouchStart(){
    this._isTouching = true;
    this._lastScrollY = window.scrollY;
  }
  _onTouchEnd(){
    this._isTouching = false;
  }

  _onUltraScrollNav(){
    if (this._externalHideRequested || !this._autoScrollSyncEnabled) return;
    if (!this._navEl) return;
    const y = window.scrollY;
    const delta = y - this._lastScrollY;
    this._lastScrollY = y;
    if (y <= this.SHOW_THRESHOLD){
      if (!this._navVisible) this._showNav();
      return;
    }
    if (this._isTouching){
      if (delta > 15 && this._navVisible) this._hideNav();
      else if (delta < -10 && !this._navVisible) this._showNav();
    }
  }

  _hideNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navVisible = false;
  }
  _showNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navVisible = true;
  }

  /* --- utilities --- */
  _debounce(fn, wait = 100){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  /* cleanup / destroy */
  _cleanup(){
    try {
      window.removeEventListener('resize', this._resizeHandler, { passive: true });
      window.removeEventListener('orientationchange', this._orientationHandler, { passive: true });
      window.removeEventListener('scroll', this._scrollHandler, { passive: true });
      window.removeEventListener('storage', this._storageHandler, { passive: true });
      window.removeEventListener('popstate', () => {});
      window.removeEventListener('modernNavCommand', this._onExternalCommandBound);
      this._disableScrollNavSync();
      try { localStorage.setItem = this._originalSetItem; } catch(e){}
    } catch(e){
      // swallow errors during cleanup
    }
    this._initialized = false;
    this._navEl = null;
  }

  destroy(){
    this._cleanup();
  }
}

/* bootstrap */
(function(){
  const nav = new ModernNavigation({
    cssPath: '/assets/css/modern-styles.min.css',
    configPath: '/assets/json/template/template.min.json',
    defaultButtonClass: 'default-button',
    leftRailWidth: '88px',
    leftRailCollapsedWidth: '72px',
    supportedLangCodes: ['th', 'en', 'ja', 'ko', 'zh', 'fr', 'de', 'es', 'it', 'pt', 'ru', 'ar', 'vi', 'id', 'ms', 'tl'],
    forceLangPrefix: true
  });

  // Expose init and instance; initialize asynchronously
  window.modernNav = nav;
  queueMicrotask(() => {
    nav.init().catch(e => console.error('ModernNavigation init failed:', e));
  });
})();