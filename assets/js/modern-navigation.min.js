/**
 * ModernNavigation - Refactored Modular Edition
 * Single-file replacement preserving existing behavior while introducing:
 * - Clear modules: EventBus, StorageAPI, NavConfigLoader, NavPrefixManager, NavRenderer, NavController
 * - Single responsibility per class, small public surface for each
 * - Easy to test / replace parts independently
 * - Preserves dev-mode safeguards and aggressive candidate probing
 *
 * Put this file in place of the previous modern-navigation.min.js
 */

(function () {
  // --- Small Feature Detection / Helpers ---
  const SUPPORTS_BC = (function () { try { return typeof BroadcastChannel !== 'undefined'; } catch (e) { return false; } })();
  const NOW = () => Date.now();

  // --- EventBus: tiny pub/sub for decoupling modules ---
  class EventBus {
    constructor() { this.listeners = new Map(); }
    on(event, fn) {
      if (!this.listeners.has(event)) this.listeners.set(event, []);
      this.listeners.get(event).push(fn);
      return () => this.off(event, fn);
    }
    off(event, fn) {
      if (!this.listeners.has(event)) return;
      const arr = this.listeners.get(event).filter(x => x !== fn);
      if (arr.length) this.listeners.set(event, arr); else this.listeners.delete(event);
    }
    emit(event, detail) {
      const arr = this.listeners.get(event);
      if (!arr || !arr.length) return;
      arr.slice().forEach(fn => { try { fn(detail); } catch (e) {} });
    }
  }

  // --- StorageAPI: safe wrappers around localStorage/sessionStorage with fallbacks ---
  class StorageAPI {
    static safeGet(key, ls = true) {
      try { return (ls ? localStorage.getItem(key) : sessionStorage.getItem(key)); } catch (e) { return null; }
    }
    static safeSet(key, value, ls = true) {
      try { (ls ? localStorage.setItem(key, value) : sessionStorage.setItem(key, value)); return true; } catch (e) { return false; }
    }
    static safeRemove(key, ls = true) {
      try { (ls ? localStorage.removeItem(key) : sessionStorage.removeItem(key)); return true; } catch (e) { return false; }
    }
  }

  // --- NavConfigLoader: fetch and provide navigation config ---
  class NavConfigLoader {
    constructor(configPath) {
      this.configPath = configPath || '/assets/json/template/template.min.json';
      this._cached = null;
    }
    async load() {
      if (this._cached) return this._cached;
      try {
        const res = await fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        this._cached = json;
        return json;
      } catch (e) {
        // fallback to empty
        return { navigation: [] };
      }
    }
  }

  // --- NavPrefixManager: all prefix parsing/generation/candidates in one place ---
  class NavPrefixManager {
    constructor(options = {}) {
      this.defaultLang = options.defaultLang || 'en';
      this.supportedLangCodes = options.supportedLangCodes || ['th','en','ja','ko','zh','fr','de','es','it','pt','ru','ar','vi','id','ms','tl'];
      this.readSelectedLang = options.readSelectedLang || (() => {
        try { return localStorage.getItem('selectedLang') || this.defaultLang; } catch (e) { return this.defaultLang; }
      });
      this.isDevMode = !!options.isDevMode;
    }

    _isLangCode(segment) {
      if (!segment) return false;
      return this.supportedLangCodes.includes(segment.toLowerCase());
    }

    normalizePath(path) {
      if (!path) return '/';
      try {
        // keep origin-less; remove repeated slashes; preserve leading slash
        const u = path.split('?')[0].split('#')[0];
        let p = u.replace(/\/+/g, '/');
        if (!p.startsWith('/')) p = '/' + p;
        // keep single slash for root
        if (p !== '/' && p.endsWith('/')) p = p.replace(/\/+$/, '');
        return p || '/';
      } catch (e) { return path || '/'; }
    }

    parse(path) {
      const p = this.normalizePath(path);
      const segments = p.split('/').filter(Boolean);
      if (segments.length > 0 && this._isLangCode(segments[0])) {
        const lang = segments[0].toLowerCase();
        const clean = segments.length > 1 ? '/' + segments.slice(1).join('/') : '/';
        return { hasLangPrefix: true, lang, cleanPath: clean, originalPath: p };
      }
      return { hasLangPrefix: false, lang: null, cleanPath: p, originalPath: p };
    }

    stripPrefix(path) {
      const parsed = this.parse(path);
      return parsed.cleanPath;
    }

    addPrefix(path, lang) {
      const base = this.normalizePath(path);
      // if already prefixed, return as-is (but ensure normalized)
      const parsed = this.parse(base);
      if (parsed.hasLangPrefix) return base;
      if (!lang) lang = this.readSelectedLang() || this.defaultLang;
      if (this.isDevMode) return base;
      return '/' + lang + (base === '/' ? '/' : base);
    }

    hasPrefix(path) {
      return this.parse(path).hasLangPrefix;
    }

    resolvePreferredLang(currentPath) {
      const parsed = this.parse(currentPath || window.location.pathname);
      if (parsed.lang) return parsed.lang;
      const sel = this.readSelectedLang();
      return sel || this.defaultLang;
    }

    // candidate generator for aggressive probing
    buildCandidates(baseUrl) {
      const base = this.normalizePath(baseUrl);
      if (this.isDevMode) return [base];
      const currentLang = this.resolvePreferredLang(window.location.pathname);
      const langs = [];
      const parsed = this.parse(window.location.pathname);
      if (parsed.lang) langs.push(parsed.lang);
      if (currentLang && !langs.includes(currentLang)) langs.push(currentLang);
      if (this.defaultLang && !langs.includes(this.defaultLang)) langs.push(this.defaultLang);
      const uniq = Array.from(new Set(langs));
      const out = [];
      uniq.forEach(lang => {
        const pref = '/' + lang;
        const c1 = pref + base;
        out.push(c1);
        out.push(c1.endsWith('/') ? c1 + 'index.html' : c1 + '/index.html');
        if (!c1.endsWith('/')) out.push(c1 + '/');
      });
      out.push(base);
      out.push(base.endsWith('/') ? base + 'index.html' : base + '/index.html');
      if (base === '/' || base === '/index.html') {
        uniq.forEach(lang => { out.push('/' + lang + '/home/'); out.push('/' + lang + '/home/index.html'); });
        out.push('/home/'); out.push('/home/index.html');
      }
      // dedupe preserve order
      const seen = new Set();
      const res = [];
      for (const c of out) {
        if (!seen.has(c)) { seen.add(c); res.push(c); }
      }
      return res;
    }
  }

  // --- NavRenderer: DOM creation and incremental updates (responsible only for DOM) ---
  class NavRenderer {
    constructor(options = {}) {
      this.containerSelector = options.containerSelector || null; // not used here; inserted at body start
      this.itemClass = options.itemClass || 'nav-item';
      this.labelClass = options.labelClass || 'label';
      this.svgWrapperClass = options.svgWrapperClass || 'svg-wrapper';
      this.defaultButtonClass = options.defaultButtonClass || 'default-button';
      this.eventBus = options.eventBus;
      this.navElement = null;
    }

    createNavElement(fragment) {
      const nav = document.createElement('div');
      nav.className = 'bottom-nav';
      nav.setAttribute('role', 'navigation');
      nav.appendChild(fragment);
      return nav;
    }

    mount(navEl) {
      if (!navEl) return;
      if (document.querySelector('.bottom-nav')) return;
      document.body.insertBefore(navEl, document.body.firstChild);
      this.navElement = navEl;
    }

    unmount() {
      if (this.navElement && this.navElement.parentNode) {
        this.navElement.parentNode.removeChild(this.navElement);
        this.navElement = null;
      }
    }

    buildItemsFragment(navConfig, currentLang, navPrefixManager) {
      const frag = document.createDocumentFragment();
      const navItems = Array.isArray(navConfig) ? navConfig : [];
      navItems.forEach(item => {
        const a = document.createElement('a');
        a.className = `${this.itemClass} ${item.customClass || this.defaultButtonClass}`;
        a.setAttribute('role', 'menuitem');

        // store baseUrl raw for re-generation; do not prefix now
        const baseUrl = item.go_url || item.url || '/';
        a.dataset.baseUrl = baseUrl;

        // back-compat
        if (item.url) a.dataset.link = item.url;
        if (item.go_url) a.dataset.goUrl = item.go_url;

        // mark external
        a.dataset.isExternal = (baseUrl.startsWith('http') || baseUrl.startsWith('//')) ? 'true' : 'false';

        // href: ask prefix manager for the correct href given current page state
        try {
          a.href = navPrefixManager.addPrefix(baseUrl, navPrefixManager.resolvePreferredLang(window.location.pathname));
        } catch (e) { a.href = baseUrl; }

        // wave delegate attr (preserve appearance)
        a.setAttribute('wave-delegate', `.${this.svgWrapperClass}`);

        // icon -> wrap into svg-wrapper
        if (item.icon) {
          const tmp = document.createElement('div');
          tmp.innerHTML = item.icon;
          const wrap = document.createElement('span');
          wrap.className = this.svgWrapperClass;
          wrap.setAttribute('wave', '');
          while (tmp.firstChild) wrap.appendChild(tmp.firstChild);
          a.appendChild(wrap);
        }

        const lbl = document.createElement('div');
        lbl.className = this.labelClass;
        lbl.textContent = item[`${currentLang}_label`] || item.en_label || 'Missing Label';
        a.appendChild(lbl);

        frag.appendChild(a);
      });
      return frag;
    }

    updateHrefForItem(itemEl, newHref) {
      try { if (itemEl && itemEl.href !== newHref) itemEl.href = newHref; } catch (e) {}
    }

    updateLabelForItem(itemEl, newLabel) {
      try { const lbl = itemEl.querySelector('.' + this.labelClass); if (lbl) lbl.textContent = newLabel; } catch (e) {}
    }

    getNavElement() { return this.navElement || document.querySelector('.bottom-nav'); }

    getItems() {
      const nav = this.getNavElement();
      return nav ? Array.from(nav.querySelectorAll('.' + this.itemClass)) : [];
    }
  }

  // --- NavController: orchestrates everything, event listeners, navigation interception ---
  class NavController {
    constructor(options = {}) {
      this.configPath = options.configPath || '/assets/json/template/template.min.json';
      this.cssPath = options.cssPath || '/assets/css/modern-styles.min.css';
      this.defaultLang = options.defaultLang || 'en';
      this.eventBus = options.eventBus || new EventBus();
      this.navConfigLoader = new NavConfigLoader(this.configPath);
      this.navRenderer = new NavRenderer({ eventBus: this.eventBus, defaultButtonClass: options.defaultButtonClass || 'default-button' });
      this._supportedLangCodes = options.supportedLangCodes || ['th','en','ja','ko','zh','fr','de','es','it','pt','ru','ar','vi','id','ms','tl'];
      this.isDevMode = NavController._isLocalDev();
      this.navPrefixManager = new NavPrefixManager({
        defaultLang: this.defaultLang,
        supportedLangCodes: this._supportedLangCodes,
        readSelectedLang: () => {
          try { return localStorage.getItem('selectedLang') || this.defaultLang; } catch (e) { return this.defaultLang; }
        },
        isDevMode: this.isDevMode
      });

      this._navEl = null;
      this._initialized = false;
      this._raf = null;
      this._lastScrollY = window.scrollY;
      this._navVisible = true;
      this._externalHideRequested = false;
      this._autoScrollSyncEnabled = true;
      this.SHOW_THRESHOLD = 40;

      // binding handlers
      this._onNavClickBound = this._onNavClick.bind(this);
      this._onScrollBound = this._onScrollForActiveState.bind(this);
      this._onStorageBound = this._onStorageEvent.bind(this);
      this._onPopStateBound = this._onPopState.bind(this);
      this._onLanguageChangeBound = this._onLanguageChange.bind(this);

      // BroadcastChannel for cross-tab
      try { this._bc = SUPPORTS_BC ? new BroadcastChannel('fv-lang') : null; } catch (e) { this._bc = null; }
      if (this._bc) this._bc.onmessage = (ev) => { try { if (ev && ev.data && ev.data.lang) { this.eventBus.emit('lang:changed', ev.data.lang); } } catch (e) {} };

      // ensure CSS preconnect
      this._preconnect(this.cssPath);
    }

    static _isLocalDev() {
      try {
        const host = location.hostname || '';
        if (!host) return false;
        if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return true;
        if (host.endsWith('.local')) return true;
        if (location.port && ['3000','5173','7700','8080','3001'].includes(String(location.port))) return true;
        if (location.protocol === 'file:') return true;
        return false;
      } catch (e) { return false; }
    }

    _preconnect(path) {
      try { const u = new URL(path, location.origin); if (!document.querySelector(`link[rel="preconnect"][href="${u.origin}"]`)) { const l = document.createElement('link'); l.rel = 'preconnect'; l.href = u.origin; document.head.appendChild(l); } } catch (e) {}
    }

    async init() {
      if (this._initialized) return;
      await this._loadCSS();
      const cfg = await this.navConfigLoader.load();
      const currentLang = this._readSelectedLang() || this.defaultLang;
      const frag = this.navRenderer.buildItemsFragment(cfg.navigation || [], currentLang, this.navPrefixManager);
      const navEl = this.navRenderer.createNavElement(frag);
      this.navRenderer.mount(navEl);
      this._navEl = this.navRenderer.getNavElement();

      this._bindListeners();
      this._updateActiveState();
      this._applyScreenBehavior();
      this._initialized = true;

      // initial sync of URLs/labels
      this.syncAllUrlsAndLabels();

      // subscribe to internal events
      this.eventBus.on('lang:changed', (lang) => this._onLanguageChange(lang));
      // also listen to same-window languageChange custom event for immediate in-page notifications
      window.addEventListener('languageChange', (e) => { try { if (e?.detail?.language) this.eventBus.emit('lang:changed', e.detail.language); } catch (e) {} });

      return this;
    }

    async _loadCSS() {
      if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = this.cssPath;
      document.head.appendChild(link);
      await new Promise(resolve => { link.onload = resolve; link.onerror = resolve; });
    }

    _bindListeners() {
      if (!this._navEl) return;
      this._navEl.addEventListener('click', this._onNavClickBound, { passive: false });
      window.addEventListener('scroll', this._onScrollBound, { passive: true });
      window.addEventListener('storage', this._onStorageBound);
      window.addEventListener('popstate', this._onPopStateBound);
      window.addEventListener('modernNavCommand', (e) => this._handleExternalCommand(e), { passive: true });
      // mutation observer to update newly added links (delegates to updating DOM items)
      const mo = new MutationObserver(muts => {
        muts.forEach(m => {
          m.addedNodes.forEach(node => {
            if (node.nodeType === 1) this._updateLinksIn(node);
          });
        });
      });
      mo.observe(document.body || document.documentElement, { childList: true, subtree: true });
      this._mutationObserver = mo;
    }

    _unbindListeners() {
      if (!this._navEl) return;
      this._navEl.removeEventListener('click', this._onNavClickBound, { passive: false });
      window.removeEventListener('scroll', this._onScrollBound, { passive: true });
      window.removeEventListener('storage', this._onStorageBound);
      window.removeEventListener('popstate', this._onPopStateBound);
      if (this._mutationObserver) { try { this._mutationObserver.disconnect(); } catch (e) {} }
      if (this._bc) try { this._bc.close(); } catch (e) {}
    }

    _readSelectedLang() {
      try { return localStorage.getItem('selectedLang'); } catch (e) { return null; }
    }

    _writeSelectedLang(lang) {
      try { localStorage.setItem('selectedLang', lang); } catch (e) {}
      if (this._bc) try { this._bc.postMessage({ lang: lang, version: (Number(localStorage.getItem('langVersion')||0) + 1) }); } catch (e) {}
    }

    _updateLinksIn(root) {
      // update hrefs of anchors within a subtree according to current selectedLang
      const anchors = (root.querySelectorAll ? root.querySelectorAll('a[href]') : []);
      const sel = this._readSelectedLang() || this.defaultLang;
      anchors.forEach(a => {
        try {
          const raw = a.getAttribute('href') || '';
          if (/^(mailto:|tel:|javascript:|#)/i.test(raw)) return;
          // internal origin-only?
          const url = new URL(raw, location.origin);
          if (url.origin !== location.origin) return;
          // skip known skip prefixes
          const SKIP_PREFIXES = ['/assets/', '/static/', '/api/', '/_next/', '/favicon.ico', '/robots.txt', '/sitemap.xml'];
          if (!url.pathname.startsWith('/')) return;
          for (const p of SKIP_PREFIXES) if (url.pathname.startsWith(p)) return;
          // do not double prefix
          if (this.navPrefixManager.hasPrefix(url.pathname)) return;
          // if dev mode, do not modify
          if (this.isDevMode) return;
          // else set prefix
          const newHref = this.navPrefixManager.addPrefix(url.pathname, sel) + url.search + url.hash;
          a.setAttribute('href', newHref);
        } catch (e) {}
      });
    }

    _onNavClick(ev) {
      try {
        const anchor = ev.target && ev.target.closest ? ev.target.closest('a[href]') : null;
        if (!anchor) return;
        const raw = anchor.getAttribute('href') || '';
        if (/^(mailto:|tel:|javascript:|#)/i.test(raw)) return;
        const url = new URL(raw, location.origin);
        if (url.origin !== location.origin) return; // external
        const path = url.pathname || '/';
        // skip asset prefixes
        const SKIP_PREFIXES = ['/assets/', '/static/', '/api/', '/_next/', '/favicon.ico', '/robots.txt', '/sitemap.xml'];
        for (const p of SKIP_PREFIXES) if (path.startsWith(p)) return;

        // if link already has prefix or dev-mode, let it proceed
        if (this.navPrefixManager.hasPrefix(path) || this.isDevMode) return;

        // prevent default and attempt aggressive resolution
        ev.preventDefault();

        // record click mapping for heuristics
        try {
          const key = path + (url.search || '');
          const rawMap = sessionStorage.getItem('fv-nav-lang-map') || '{}';
          const map = JSON.parse(rawMap || '{}');
          const sel = this._readSelectedLang() || this.defaultLang;
          map[key] = { lang: sel, ts: NOW(), evidence: 'click' };
          sessionStorage.setItem('fv-nav-lang-map', JSON.stringify(map));
        } catch (e) {}

        (async () => {
          const done = await this._attemptCandidates(path, ev);
          if (!done) {
            // fallback to anchor.href
            try { window.location.assign(anchor.href); } catch (e) { window.location.href = anchor.href; }
          }
        })();
      } catch (e) {}
    }

    async _attemptCandidates(destPath, originalEvent) {
      if (this.isDevMode) return false;
      const candidates = this.navPrefixManager.buildCandidates(destPath);
      for (const c of candidates) {
        try {
          const resp = await fetch(c, { method: 'HEAD', cache: 'no-store', credentials: 'same-origin' });
          if (resp && resp.ok) {
            // found candidate
            const parsed = this.navPrefixManager.parse(c);
            if (parsed.hasLangPrefix) {
              try { localStorage.setItem('selectedLang', parsed.lang); } catch (e) {}
              try { this.eventBus.emit('lang:changed', parsed.lang); } catch (e) {}
              try { if (this._bc) this._bc.postMessage({ lang: parsed.lang, version: (Number(localStorage.getItem('langVersion')||0) + 1) }); } catch (e) {}
            }
            // preserve original query/hash if the original anchor had them
            const linkEl = originalEvent && originalEvent.target && originalEvent.target.closest ? originalEvent.target.closest('a[href]') : null;
            const urlObj = new URL(c, location.origin);
            try {
              if (linkEl) {
                const raw = linkEl.getAttribute('href') || '';
                const resolved = new URL(raw, location.origin);
                if (resolved.search) urlObj.search = resolved.search;
                if (resolved.hash) urlObj.hash = resolved.hash;
              }
            } catch (e) {}
            try { window.location.assign(urlObj.toString()); } catch (e) { window.location.href = urlObj.toString(); }
            return true;
          }
        } catch (e) {
          // try next
        }
      }
      return false;
    }

    _onScrollForActiveState() {
      if (this._raf) return;
      this._raf = requestAnimationFrame(() => {
        this._updateActiveState();
        this._raf = null;
      });
    }

    _updateActiveState() {
      if (!this._navEl) return;
      const currentPath = window.location.pathname || '/';
      const items = this.navRenderer.getItems();
      items.forEach(it => {
        const navLink = it.dataset.link || it.dataset.goUrl || (it.dataset.baseUrl || '');
        const should = this._isNavLinkActive(navLink, currentPath);
        const was = it.classList.contains('active-1');
        it.classList.toggle('active-1', should);
        const wrap = it.querySelector('.svg-wrapper');
        if (wrap && should && !was) {
          wrap.classList.remove('animate'); void wrap.offsetWidth; wrap.classList.add('animate');
        }
      });
    }

    _isNavLinkActive(navLink, currentPath) {
      if (!navLink) return false;
      const normNav = this.navPrefixManager.normalizePath(navLink);
      const parsedCur = this.navPrefixManager.parse(currentPath);
      const cleanCur = parsedCur.cleanPath;
      // home special-case
      if (normNav === '/' || normNav === '/index.html') {
        return cleanCur === '/' || cleanCur === '/index.html' || (parsedCur.hasLangPrefix && parsedCur.cleanPath === '/');
      }
      // exact match or parent match
      if (cleanCur === normNav) return true;
      const navWith = normNav.endsWith('/') ? normNav : normNav + '/';
      const curWith = cleanCur.endsWith('/') ? cleanCur : cleanCur + '/';
      if (curWith.startsWith(navWith)) return true;
      return false;
    }

    _onStorageEvent(e) {
      try {
        if (e.key === 'selectedLang' || e.key === 'langVersion') {
          const newLang = localStorage.getItem('selectedLang') || this.defaultLang;
          this.eventBus.emit('lang:changed', newLang);
        }
      } catch (e) {}
    }

    _onPopState(ev) {
      try {
        const parsed = this.navPrefixManager.parse(window.location.pathname);
        const langInUrl = parsed.lang;
        const state = ev.state || {};
        const stateVersion = state && state.langVersion ? Number(state.langVersion) : null;
        const storedVersion = (function(){ try { return Number(localStorage.getItem('langVersion')||0); } catch(e){ return 0; } })();
        const current = this._readSelectedLang() || this.defaultLang;
        if ((stateVersion !== null && stateVersion !== storedVersion) || (langInUrl && langInUrl !== current)) {
          if (langInUrl && langInUrl !== current) {
            try { localStorage.setItem('selectedLang', langInUrl); } catch (e) {}
            this.eventBus.emit('lang:changed', langInUrl);
          }
          this.syncAllUrlsAndLabels();
          if (!this.isDevMode) { try { window.location.reload(); return; } catch (e) {} }
        }
        this._updateActiveState();
        this.syncAllUrlsAndLabels();
      } catch (e) {}
    }

    _onLanguageChange(lang) {
      if (!lang) return;
      this._writeSelectedLang(lang);
      this.syncAllUrlsAndLabels();
      this._updateActiveState();
    }

    // update both hrefs and labels according to current language
    syncAllUrlsAndLabels() {
      if (!this._navEl) return;
      const items = this.navRenderer.getItems();
      const lang = this._readSelectedLang() || this.defaultLang;
      // update each item using baseUrl stored on element
      items.forEach(it => {
        const base = it.dataset.baseUrl || it.dataset.goUrl || it.dataset.link;
        if (!base) return;
        if (it.dataset.isExternal === 'true') return;
        try {
          const newHref = this.navPrefixManager.addPrefix(base, this.navPrefixManager.resolvePreferredLang(window.location.pathname));
          this.navRenderer.updateHrefForItem(it, newHref);
        } catch (e) {}
        // update label from config if possible
        try {
          const cfg = this.navConfigLoader._cached && (this.navConfigLoader._cached.navigation || []).find(n => (n.url === (it.dataset.link || '')) || (n.go_url === (it.dataset.goUrl || '')));
          if (cfg) {
            const newLabel = cfg[`${lang}_label`] || cfg.en_label || '';
            if (newLabel) this.navRenderer.updateLabelForItem(it, newLabel);
          }
        } catch (e) {}
      });
    }

    _applyScreenBehavior() {
      // simple mount/unmount decisions: if wide => left rail; if narrow => mobile
      const isMobile = window.innerWidth < 768;
      const nav = this._navEl;
      if (!nav) return;
      nav.classList.toggle('vertical', !isMobile);
      if (isMobile) {
        this._unmountLeftRailIfMounted();
        this._enableScrollNavSync();
      } else {
        this._mountLeftRailIfNeeded();
        this._disableScrollNavSync();
      }
    }

    _mountLeftRailIfNeeded() {
      if (!this._navEl) return;
      if (document.body.classList.contains('has-left-rail')) return;
      const nav = this._navEl;
      const siteMain = document.createElement('div');
      siteMain.className = 'site-main';
      const nodes = Array.from(document.body.childNodes);
      for (let node of nodes) {
        if (node === nav) continue;
        siteMain.appendChild(node);
      }
      document.body.appendChild(siteMain);
      document.body.classList.add('has-left-rail');
      document.documentElement.style.setProperty('--left-rail-width', '88px');
      document.documentElement.style.setProperty('--left-rail-collapsed-width', '72px');
      nav.style.position = 'fixed';
      nav.style.top = '0';
      nav.style.left = '0';
      nav.style.transform = 'none';
      nav.style.zIndex = '1000';
      nav.style.height = '100vh';
      nav.style.overflow = 'auto';
      siteMain.style.marginLeft = '88px';
    }

    _unmountLeftRailIfMounted() {
      if (!this._navEl) return;
      if (!document.body.classList.contains('has-left-rail')) return;
      const nav = this._navEl;
      const siteMain = document.querySelector('.site-main');
      if (siteMain) {
        const children = Array.from(siteMain.childNodes);
        for (let ch of children) document.body.insertBefore(ch, siteMain);
        if (siteMain.parentNode) siteMain.parentNode.removeChild(siteMain);
      }
      document.body.classList.remove('has-left-rail');
      document.documentElement.style.removeProperty('--left-rail-width');
      document.documentElement.style.removeProperty('--left-rail-collapsed-width');
      nav.style.position = ''; nav.style.top = ''; nav.style.height = ''; nav.style.left = ''; nav.style.transform = ''; nav.style.zIndex = ''; nav.style.overflow = '';
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach(el => { if (el.style && el.style.marginLeft === '88px') el.style.marginLeft = ''; });
    }

    _enableScrollNavSync() {
      if (this._navScrollSyncEnabled) return;
      window.addEventListener('scroll', this._onMobileScrollBound = this._onMobileScroll.bind(this), { passive: true });
      window.addEventListener('touchstart', this._onTouchStartBound = this._onTouchStart.bind(this), { passive: true });
      window.addEventListener('touchend', this._onTouchEndBound = this._onTouchEnd.bind(this), { passive: true });
      if (this._navEl && !this._externalHideRequested) {
        this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
        this._navEl.style.transform = 'translateZ(0) translateY(0%)';
        this._navVisible = true;
      }
      this._navScrollSyncEnabled = true;
    }

    _disableScrollNavSync() {
      if (!this._navScrollSyncEnabled) return;
      window.removeEventListener('scroll', this._onMobileScrollBound, { passive: true });
      window.removeEventListener('touchstart', this._onTouchStartBound, { passive: true });
      window.removeEventListener('touchend', this._onTouchEndBound, { passive: true });
      if (this._navEl && !this._externalHideRequested) {
        this._navEl.style.transform = 'translateZ(0) translateY(0%)';
        this._navVisible = true;
      }
      this._navScrollSyncEnabled = false;
    }

    _onTouchStart() { this._touching = true; this._lastScrollY = window.scrollY; }
    _onTouchEnd() { this._touching = false; }

    _onMobileScroll() {
      if (this._externalHideRequested || !this._autoScrollSyncEnabled) return;
      const y = window.scrollY;
      const delta = y - this._lastScrollY;
      this._lastScrollY = y;
      if (y <= this.SHOW_THRESHOLD) {
        if (!this._navVisible) this._showNav();
        return;
      }
      if (this._touching) {
        if (delta > 15 && this._navVisible) this._hideNav();
        else if (delta < -10 && !this._navVisible) this._showNav();
      }
    }

    _handleExternalCommand(ev) {
      try {
        const cmd = ev?.detail?.command;
        const reason = ev?.detail?.reason || 'external';
        if (cmd === 'hide') this.hideNav(reason);
        else if (cmd === 'show' || cmd === 'restore') this.showNav(reason);
        else if (cmd === 'toggle') this.toggleNav(reason);
      } catch (e) {}
    }

    hideNav(reason = 'external') {
      if (!this._navEl) return;
      this._externalHideRequested = true;
      this._autoScrollSyncEnabled = false;
      this._navEl.style.transform = 'translateZ(0) translateY(100%)';
      this._navVisible = false;
      this.eventBus.emit('nav:state', { state: 'hidden', reason, visible: this._navVisible });
    }

    showNav(reason = 'external') {
      if (!this._navEl) return;
      this._externalHideRequested = false;
      this._autoScrollSyncEnabled = true;
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
      this.eventBus.emit('nav:state', { state: 'shown', reason, visible: this._navVisible });
    }

    toggleNav(reason = 'external') {
      if (this._externalHideRequested || !this._navVisible) this.showNav(reason); else this.hideNav(reason);
    }

    isNavVisible() { return this._navVisible && !this._externalHideRequested; }

    // Public destroy
    destroy() {
      this._unbindListeners();
      this.navRenderer.unmount();
      this._navEl = null;
      this._initialized = false;
    }
  }

  // --- Bootstrap: expose single instance
  const controller = new NavController({
    cssPath: '/assets/css/modern-styles.min.css',
    configPath: '/assets/json/template/template.min.json',
    defaultLang: 'en',
    supportedLangCodes: ['th','en','ja','ko','zh','fr','de','es','it','pt','ru','ar','vi','id','ms','tl'],
    defaultButtonClass: 'default-button'
  });

  // Init asynchronously but expose API immediately
  queueMicrotask(() => { controller.init().catch(e => console.error('ModernNavigation init failed:', e)); });

  // Attach global handle similar to previous interface
  window.modernNav = {
    hideNav: (r) => controller.hideNav(r),
    showNav: (r) => controller.showNav(r),
    toggleNav: (r) => controller.toggleNav(r),
    isNavVisible: () => controller.isNavVisible(),
    destroy: () => controller.destroy(),
    _internal: { controller } // for debugging/testing
  };

})();