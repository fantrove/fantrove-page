/**
 * ModernNavigation (improved)
 * - Mobile: bottom fixed nav with hide-on-scroll behavior
 * - Tablet+Desktop: left rail inserted into layout and fixed at left (no bottom gap)
 * - Robust event handling, debounce, CSS var sync, safe mount/unmount
 * - Preserves labels, active state, go_url, language support
 * - Updated: Uses <a> elements instead of <button> for better semantics
 * - EXTENDED: Support external hide/show commands via public methods & custom events
 * - EXTENDED v2: Smart URL Matcher - Auto-detects and strips language prefixes (/th/, /en/, etc.)
 * - EXTENDED v3: Aggressive language-prefixed navigation: try multiple candidate URLs (with/without /index.html, with language prefixes) and route to the first OK result.
 * - DEV-SAFE: When running on local/dev hosts (localhost, 127.0.0.1, 0.0.0.0, *.local, or common dev ports) aggressive candidate probing is disabled to avoid "Reading file failed" during development.
 * - FIXED: Update navigation URLs on popstate to match current language
 * - FIXED: Clear separation between local dev mode (no lang prefix) and production mode
 */

/* --- [BEGIN: Wave Effect Loader] --- */
(function(){
  // ตรวจสอบว่ามี wave-effect.min.js อยู่แล้วหรือยัง ถ้ายังไม่มีให้เพิ่มเข้าไป
  var waveScriptSrc = "https://marcumat-js.pages.dev/dist/wave-effect.js";
  if (!document.querySelector('script[src="' + waveScriptSrc + '"]')) {
    var script = document.createElement('script');
    script.src = waveScriptSrc;
    script.async = true;
    document.head.appendChild(script);
  }
})();
/* --- [END: Wave Effect Loader] --- */

class ModernNavigation {
  constructor(config = {}) {
    this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
    this.configPath = config.configPath || '/assets/json/buttons.min.json';
    this.activeClass = config.activeClass || 'active-1';
    this.navItemSelector = config.navItemSelector || '.nav-item';
    this.defaultButtonClass = config.defaultButtonClass || 'default-button';

    // left rail sizes (strings with units)
    this.leftRailWidth = config.leftRailWidth || '88px';
    this.leftRailCollapsedWidth = config.leftRailCollapsedWidth || '72px';

    this.defaultLang = 'en';
    this.currentLang = (function(){ try { return localStorage.getItem('selectedLang'); } catch(e){ return null; } })() || this.defaultLang;

    this._initialized = false;
    this._config = null;
    this._navEl = null;

    // state
    this._isTouching = false;
    this._navVisible = true;
    this._lastScrollY = window.scrollY;
    this._rafId = null;
    this.SHOW_THRESHOLD = 40;

    // ✅ External control state (can override scroll behavior)
    this._externalHideRequested = false;
    this._autoScrollSyncEnabled = true;

    // saved original localStorage.setItem for restoration (not used to override here)
    // keep reference if needed elsewhere
    try { this._originalSetItem = localStorage.setItem.bind(localStorage); } catch (e) { this._originalSetItem = null; }

    // ✅ Smart URL Matcher: รายการภาษาที่รองรับ (ISO 639-1 codes ทั่วไป)
    this._supportedLangCodes = config.supportedLangCodes || [
      'th', 'en', 'ja', 'ko', 'zh', 'fr', 'de', 'es', 'it', 'pt', 'ru', 'ar', 'vi', 'id', 'ms', 'tl'
    ];

    // ✅ DEV MODE: ตรวจสอบว่าอยู่ใน local development หรือไม่
    this._isDevMode = ModernNavigation._isLocalDev();
    
    // ✅ ใน dev mode จะไม่ force language prefix และไม่ทำ aggressive navigation
    this.forceLangPrefix = this._isDevMode ? false : ((typeof config.forceLangPrefix !== 'undefined') ? !!config.forceLangPrefix : true);

    // bound handlers to enable removal and avoid duplicates
    this._resizeHandler = this._debounce(this._applyScreenBehavior.bind(this), 120);
    this._orientationHandler = this._applyScreenBehavior.bind(this);
    this._scrollHandler = this._onScrollForActiveState.bind(this);
    this._storageHandler = this._onStorageEvent.bind(this);
    this._onUltraScrollNavBound = this._onUltraScrollNav.bind(this);
    this._onTouchStartBound = this._onTouchStart.bind(this);
    this._onTouchEndBound = this._onTouchEnd.bind(this);
    this._onNavClickBound = this._onNavClick.bind(this);
    this._onExternalCommandBound = this._onExternalCommand.bind(this);
    
    // ✅ FIXED: Bind popstate handler แยกเพื่อให้สามารถอัพเดท URL ได้ถูกต้อง
    this._popStateHandlerBound = this._onPopState.bind(this);

    // BroadcastChannel listener for language updates (languageManager posts to 'fv-lang')
    try { this._bc = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('fv-lang') : null; } catch (e) { this._bc = null; }
  }

  /* public init */
  async init() {
    if (this._initialized) return;
    try {
      ModernNavigation._preconnect(this.configPath);
      await this._loadCSS();
      this._config = await this._fetchConfig();
      const fragment = this._createNavigationItemsFragment();
      this._injectNavigation(fragment);
      this._navEl = document.querySelector('.bottom-nav');
      if (!this._navEl) throw new Error('navigation element not created');

      // initial GPU hint
      this._navEl.style.willChange = 'transform';

      this._bindBaseListeners();
      this._updateActiveState(); // initial active
      this._applyScreenBehavior(); // mount/unmount according to screen
      this._initialized = true;
      
      // ✅ FIXED: ตรวจสอบและอัพเดท URL ตอน init ให้ตรงกับภาษาปัจจุบัน
      this._syncNavUrlsWithCurrentLanguage();
      
    } catch (err) {
      this._cleanup();
      console.error('ModernNavigation init error:', err);
      throw err;
    }
  }

  /* --- static helpers --- */
  static _preconnect(configPath){
    try {
      const url = new URL(configPath, location.origin);
      if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)){
        const l = document.createElement('link');
        l.rel = 'preconnect';
        l.href = url.origin;
        document.head.appendChild(l);
      }
    } catch (_){}
  }

  /* helper to detect local/dev hosts to avoid aggressive candidate fetches */
  static _isLocalDev() {
    try {
      const host = location.hostname || '';
      if (!host) return false;
      if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return true;
      if (host.endsWith('.local')) return true;
      if (location.port && ['3000','5173','7700','8080','3001'].includes(String(location.port))) return true;
      // ✅ เพิ่มการตรวจสอบ file:// protocol
      if (location.protocol === 'file:') return true;
      return false;
    } catch (e) { return false; }
  }

  /* --- CSS / config loading --- */
  async _loadCSS(){
    if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = this.cssPath;
    document.head.appendChild(link);
    await new Promise(resolve => { link.onload = resolve; link.onerror = resolve; });
  }

  async _fetchConfig(){
    try {
      const res = await fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      // fallback to empty navigation
      return { navigation: [] };
    }
  }

  /* --- ✅ Smart URL Matcher: Core Logic --- */
  
  /**
   * ตรวจสอบว่า path segment เป็นรหัสภาษาที่รองรับหรือไม่
   * @param {string} segment - path segment เช่น 'th', 'en'
   * @returns {boolean}
   */
  _isLangCode(segment) {
    return this._supportedLangCodes.includes(segment.toLowerCase());
  }

  /**
   * แยก language prefix ออกจาก URL path
   * @param {string} path - URL path เช่น '/th/data/verse/discover'
   * @returns {object} { lang: 'th', cleanPath: '/data/verse/discover', originalPath: '/th/data/verse/discover' }
   */
  _parseUrlPath(path) {
    // ลบ trailing slash ออกก่อน (ยกเว้นกรณีเป็น root /)
    const normalizedPath = path.replace(/\/+$/, '') || '/';
    const segments = normalizedPath.split('/').filter(s => s.length > 0);
    
    // ตรวจสอบว่า segment แรกเป็นรหัสภาษาหรือไม่
    if (segments.length > 0 && this._isLangCode(segments[0])) {
      const lang = segments[0].toLowerCase();
      // สร้าง clean path โดยลบ language prefix ออก
      const cleanSegments = segments.slice(1);
      const cleanPath = cleanSegments.length > 0 ? '/' + cleanSegments.join('/') : '/';
      
      return {
        lang: lang,
        cleanPath: cleanPath,
        originalPath: normalizedPath,
        hasLangPrefix: true
      };
    }
    
    // กรณีไม่มี language prefix
    return {
      lang: null,
      cleanPath: normalizedPath,
      originalPath: normalizedPath,
      hasLangPrefix: false
    };
  }

  /**
   * ตรวจสอบว่า nav link ตรงกับ current path หรือไม่ (รองรับทั้งแบบมีและไม่มี language prefix)
   * @param {string} navLink - URL จาก config เช่น '/data/verse/discover'
   * @param {string} currentPath - URL ปัจจุบัน เช่น '/th/data/verse/discover'
   * @returns {boolean}
   */
  _isNavLinkActive(navLink, currentPath) {
    // Normalize navLink (ลบ trailing slash)
    const normalizedNavLink = navLink.replace(/\/+$/, '') || '/';
    
    // แยก current path
    const parsed = this._parseUrlPath(currentPath);
    const cleanCurrentPath = parsed.cleanPath;
    
    // กรณีพิเศษ: หน้าแรก (home)
    if (normalizedNavLink === '/' || normalizedNavLink === '/index.html') {
      // ตรวจสอบว่าเป็น home หรือไม่ (ทั้งแบบมีภาษาและไม่มีภาษา)
      const isHome = cleanCurrentPath === '/' || 
                     cleanCurrentPath === '/index.html' || 
                     currentPath === '/' || 
                     currentPath === '/index.html' ||
                     (parsed.hasLangPrefix && cleanCurrentPath === '/');
      return isHome;
    }
    
    // เปรียบเทียบแบบ exact match ก่อน (กรณีไม่มี language prefix)
    if (cleanCurrentPath === normalizedNavLink) {
      return true;
    }
    
    // เปรียบเทียบแบบ startsWith (สำหรับหน้าย่อย)
    // ต้องตรวจสอบว่าเป็นการ match แบบสมบูรณ์ ไม่ใช่แค่ขึ้นต้นด้วย
    const navLinkWithSlash = normalizedNavLink.endsWith('/') ? normalizedNavLink : normalizedNavLink + '/';
    const currentWithSlash = cleanCurrentPath.endsWith('/') ? cleanCurrentPath : cleanCurrentPath + '/';
    
    // กรณี navLink เป็น parent path ของ current path
    if (currentWithSlash.startsWith(navLinkWithSlash)) {
      return true;
    }
    
    // กรณี exact match แบบไม่มี trailing slash
    if (cleanCurrentPath === normalizedNavLink) {
      return true;
    }
    
    return false;
  }

  /**
   * สร้าง URL สำหรับ navigation link โดยอัตโนมัติเติม language prefix ตาม selected/current language
   * @param {string} baseUrl - URL จาก config เช่น '/data/verse/discover'
   * @returns {string} URL ที่เติม language prefix แล้ว (ถ้าจำเป็น)
   */
  _generateNavUrl(baseUrl) {
    // ✅ DEV MODE: ใน localhost ไม่เติม language prefix เลย
    if (this._isDevMode) {
      const raw = baseUrl || '/';
      if (raw.startsWith('http') || raw.startsWith('//') || raw.startsWith('#')) return raw;
      return raw.startsWith('/') ? raw : '/' + raw;
    }

    // Normalize
    const raw = baseUrl || '/';
    if (raw.startsWith('http') || raw.startsWith('//') || raw.startsWith('#')) return raw;
    const normalizedBase = raw.startsWith('/') ? raw : '/' + raw;

    // Determine current path parse
    const currentPath = window.location.pathname;
    const parsed = this._parseUrlPath(currentPath);

    // Preferred lang order: lang from current path (if present), then this.currentLang, then default
    const preferredLang = parsed.lang || this.currentLang || this.defaultLang;

    // If already prefixed in baseUrl return as-is
    const baseSegments = normalizedBase.split('/').filter(s => s.length > 0);
    if (baseSegments.length > 0 && this._isLangCode(baseSegments[0])) {
      return normalizedBase;
    }

    // If forceLangPrefix enabled and preferredLang present, always prefix
    if (this.forceLangPrefix && preferredLang) {
      return '/' + preferredLang + (normalizedBase === '/' ? '/' : normalizedBase);
    }

    // Otherwise return base as-is
    return normalizedBase;
  }

  /* --- Build candidate URLs for aggressive navigation --- */
  _buildCandidatesForDestination(baseUrl) {
    // ✅ DEV MODE: ไม่สร้าง candidates ให้ซับซ้อนใน localhost
    if (this._isDevMode) {
      const base = baseUrl.startsWith('/') ? baseUrl : '/' + baseUrl;
      return [base];
    }

    // baseUrl should be path-only (starting with /)
    const base = baseUrl.startsWith('/') ? baseUrl : '/' + baseUrl;
    const parsedCurrent = this._parseUrlPath(window.location.pathname);
    const candidates = [];
    const tried = new Set();

    const langsToTry = [];
    if (parsedCurrent.lang) langsToTry.push(parsedCurrent.lang);
    if (this.currentLang && !langsToTry.includes(this.currentLang)) langsToTry.push(this.currentLang);
    if (this.defaultLang && !langsToTry.includes(this.defaultLang)) langsToTry.push(this.defaultLang);

    // ensure unique
    const uniqLangs = Array.from(new Set(langsToTry));

    // For each lang produce variants
    uniqLangs.forEach(lang => {
      const pref = '/' + lang;
      const c1 = pref + base; // /lang/path or /lang/
      const c2 = c1.endsWith('/') ? c1 + 'index.html' : c1 + '/index.html';
      candidates.push(c1);
      candidates.push(c2);
      // also try trailing slash versions
      if (!c1.endsWith('/')) candidates.push(c1 + '/');
    });

    // Add non-prefixed variants last
    candidates.push(base);
    candidates.push(base.endsWith('/') ? base + 'index.html' : base + '/index.html');
    if (!base.endsWith('/')) candidates.push(base + '/');

    // Also try common mapping for home root
    if (base === '/' || base === '/index.html') {
      uniqLangs.forEach(lang => {
        candidates.push('/' + lang + '/home/');
        candidates.push('/' + lang + '/home/index.html');
      });
      candidates.push('/home/');
      candidates.push('/home/index.html');
    }

    // dedupe preserving order
    const out = [];
    for (const c of candidates) {
      if (!tried.has(c)) {
        tried.add(c);
        out.push(c);
      }
    }
    return out;
  }

  async _tryNavigateCandidates(destinationPath, originalEvent) {
    // ✅ DEV MODE: ข้าม aggressive navigation ทั้งหมดใน localhost
    if (this._isDevMode) return false;

    if (!destinationPath || /^(mailto:|tel:|javascript:|#)/i.test(destinationPath)) {
      return false;
    }
    try {
      const candidates = this._buildCandidatesForDestination(destinationPath);
      for (const c of candidates) {
        try {
          const resp = await fetch(c, { method: 'HEAD', cache: 'no-store', credentials: 'same-origin' });
          if (resp && resp.ok) {
            // Found a valid candidate. If it contains a language prefix, extract it.
            const p = this._parseUrlPath(c);
            const foundLang = p && p.hasLangPrefix ? p.lang : null;

            // Update selectedLang & languageManager if present
            try {
              if (foundLang) {
                try { localStorage.setItem('selectedLang', foundLang); } catch(e){}
                if (window.languageManager && typeof window.languageManager.updatePageLanguage === 'function') {
                  // Update language on-the-fly but do not block navigation; try to do it before navigation if possible
                  try {
                    // If current selectedLang differs, update it (non-blocking)
                    if ((window.languageManager.selectedLang || '') !== foundLang) {
                      // call without waiting; languageManager will update page content where possible
                      window.languageManager.updatePageLanguage(foundLang, { updateHistory: false }).catch(()=>{});
                    }
                  } catch (e){}
                }
              }
            } catch (e){}

            // Preserve search/hash from original link if it had them; else keep current location.search/hash
            const urlObj = new URL(c, location.origin);
            // If originalEvent came from anchor element that had query/hash, prefer them
            try {
              const linkEl = originalEvent && originalEvent.target && originalEvent.target.closest ? originalEvent.target.closest('a[href]') : null;
              if (linkEl) {
                const raw = linkEl.getAttribute('href') || '';
                if (raw) {
                  const resolved = new URL(raw, location.origin);
                  if (resolved.search) urlObj.search = resolved.search;
                  if (resolved.hash) urlObj.hash = resolved.hash;
                }
              }
            } catch (e){}
            // navigate to found URL
            const finalUrl = urlObj.toString();
            try {
              // Prefer history.replaceState if same-document navigation is desired, otherwise assign
              window.location.assign(finalUrl);
            } catch (e) {
              try { location.href = finalUrl; } catch(e) {}
            }
            return true;
          }
        } catch (e) {
          // failed HEAD for candidate, try next
        }
      }
    } catch (e) {
      // fallback: nothing
    }
    return false;
  }

  /* --- build nav DOM --- */
  _createNavigationItemsFragment(){
    const fragment = document.createDocumentFragment();
    const config = this._config?.navigation || [];
    const lang = this.currentLang || this.defaultLang;
    
    // ตรวจสอบ current URL เพื่อกำหนด language prefix
    const currentPath = window.location.pathname;
    const parsed = this._parseUrlPath(currentPath);
    
    for (let i = 0; i < config.length; i++){
      const item = config[i];
      const link = document.createElement('a');
      link.className = `nav-item ${item.customClass || this.defaultButtonClass}`;
      
      // ✅ ใช้ URL ที่ปรับ language prefix อัตโนมัติ (ปรับให้ใช้ this.currentLang / forceLangPrefix)
      const baseUrl = item.go_url || item.url || '#';
      link.href = this._generateNavUrl(baseUrl);
      
      link.setAttribute('role', 'menuitem');
      
      // เก็บ base URL (ไม่มี language prefix) ไว้สำหรับตรวจสอบ active state
      if (item.url) link.dataset.link = item.url;
      if (item.go_url) link.dataset.goUrl = item.go_url;
      
      // เก็บข้อมูลว่าเป็น external link หรือไม่
      link.dataset.isExternal = baseUrl.startsWith('http') || baseUrl.startsWith('//');

      // เพิ่ม wave-delegate=".svg-wrapper" ในลิงก์
      link.setAttribute('wave-delegate', '.svg-wrapper');

      if (item.icon){
        // create a temp container to parse the icon HTML, then wrap the SVG (or nodes) with a span.svg-wrapper
        const tmp = document.createElement('div');
        tmp.innerHTML = item.icon;
        const wrapper = document.createElement('span');
        wrapper.className = 'svg-wrapper';

        // เพิ่ม wave ลงใน svg-wrapper
        wrapper.setAttribute('wave', '');

        while (tmp.firstChild) wrapper.appendChild(tmp.firstChild);
        link.appendChild(wrapper);
      }
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
      link.appendChild(label);
      fragment.appendChild(link);
    }
    return fragment;
  }

  _injectNavigation(fragment){
    if (document.querySelector('.bottom-nav')) return;
    const nav = document.createElement('div');
    nav.className = 'bottom-nav';
    nav.setAttribute('role', 'navigation');
    nav.appendChild(fragment);
    // Insert as first child for deterministic mounting
    document.body.insertBefore(nav, document.body.firstChild);
  }

  /* --- listeners / lifecycle --- */
  _bindBaseListeners(){
    if (!this._navEl) return;
    // click delegated to nav element
    this._navEl.addEventListener('click', this._onNavClickBound, { passive: false });

    // active state ref updates on scroll (rAF)
    window.addEventListener('scroll', this._scrollHandler, { passive: true });

    // storage listener for language changes
    window.addEventListener('storage', this._storageHandler);
    
    // ✅ External command listener (hide/show from other systems)
    window.addEventListener('modernNavCommand', this._onExternalCommandBound);
    
    // ✅ FIXED: ใช้ bound handler ที่แยกออกมาสำหรับ popstate
    window.addEventListener('popstate', this._popStateHandlerBound);
    
    // NOTE: We DO NOT override localStorage.setItem. Rely on:
    //  - languageChange CustomEvent (same-window)
    //  - BroadcastChannel 'fv-lang' (cross-tab & same-origin)
    //  - storage event (cross-tab fallback)

    // languageChange custom event also supported by _updateLabels
    window.addEventListener('languageChange', (e) => {
      if (e?.detail?.language) {
        this._onSelectedLangChange(e.detail.language);
        // ✅ อัปเดต URLs ทั้งหมดเมื่อเปลี่ยนภาษา
        this._updateAllNavUrls();
      }
    });

    // BroadcastChannel listener (if available) to capture languageManager._incLangVersion messages
    if (this._bc) {
      try {
        this._bc.onmessage = (ev) => {
          try {
            if (ev && ev.data && ev.data.lang) {
              this._onSelectedLangChange(ev.data.lang);
              this._updateAllNavUrls();
            }
          } catch (e) {}
        };
      } catch (e) {}
    }
  }

  _unbindBaseListeners(){
    if (!this._navEl) return;
    // remove click listener
    this._navEl.removeEventListener('click', this._onNavClickBound, { passive: false });
    window.removeEventListener('scroll', this._scrollHandler, { passive: true });
    window.removeEventListener('storage', this._storageHandler, { passive: true });
    
    // ✅ FIXED: ลบ popstate handler ที่ถูกต้อง
    window.removeEventListener('popstate', this._popStateHandlerBound);
    
    window.removeEventListener('languageChange', () => {}); // no-op
    // ✅ Remove external command listener
    window.removeEventListener('modernNavCommand', this._onExternalCommandBound);
    // restore localStorage.setItem only if we had overridden it (we don't override now)
    // so nothing to restore here.
  }

  /* --- ✅ FIXED: PopState Handler แยกออกมาเพื่อจัดการการย้อนกลับอย่างถูกต้อง --- */
  _onPopState(ev) {
    try {
      const parsed = this._parseUrlPath(window.location.pathname);
      const langInUrl = parsed.lang;
      const state = ev.state || {};
      const stateVersion = state && state.langVersion ? Number(state.langVersion) : null;
      const storedVersion = (function(){ try { return Number(localStorage.getItem('langVersion')||0); } catch(e){return 0;} })();
      const current = this.currentLang || this.defaultLang;
      
      // ✅ FIXED: ตรวจสอบว่าภาษาใน URL ตรงกับภาษาปัจจุบันหรือไม่
      const langFromUrl = langInUrl || current;
      
      if ((stateVersion !== null && stateVersion !== storedVersion) || (langInUrl && langInUrl !== current)) {
        // ✅ FIXED: อัพเดทภาษาปัจจุบันให้ตรงกับ URL
        if (langInUrl && langInUrl !== current) {
          this.currentLang = langInUrl;
          try { localStorage.setItem('selectedLang', langInUrl); } catch(e){}
        }
        
        // ✅ FIXED: อัพเดท URL ทั้งหมดในแถบนำทางให้ตรงกับภาษาใหม่
        this._syncNavUrlsWithCurrentLanguage();
        
        if (!this._isDevMode) {
          try { window.location.reload(); return; } catch(e){}
        }
      }
      
      // ✅ FIXED: อัพเดท active state และ URL ให้ตรงกับหน้าปัจจุบัน
      this._updateActiveState();
      this._syncNavUrlsWithCurrentLanguage();
      
    } catch (e) {
      console.error('PopState handler error:', e);
    }
  }

  /* --- ✅ NEW: ซิงค์ URL ทั้งหมดให้ตรงกับภาษาปัจจุบัน --- */
  _syncNavUrlsWithCurrentLanguage() {
    if (!this._navEl) return;
    
    // อัพเดท currentLang จาก localStorage อีกครั้งเพื่อความแน่ใจ
    try {
      const storedLang = localStorage.getItem('selectedLang');
      if (storedLang && storedLang !== this.currentLang) {
        this.currentLang = storedLang;
      }
    } catch(e) {}
    
    // อัพเดท URL ทั้งหมด
    this._updateAllNavUrls();
    
    // อัพเดท labels ด้วย
    this._updateLabels(this.currentLang);
  }

  /* --- click handling --- */
  _onNavClick(event){
    const item = event.target.closest(this.navItemSelector);
    if (!item) return;
    
    // ตรวจสอบว่าเป็น external link หรือไม่
    const isExternal = item.dataset.isExternal === 'true';
    if (isExternal) {
      // ปล่อยให้ default behavior จัดการ external links
      return;
    }
    
    // For anchor elements, let default behavior handle navigation
    // unless we need to intercept for custom routing
    const targetLink = item.dataset.link;
    const goLink = item.dataset.goUrl;
    const destination = goLink || targetLink;
    
    if (!destination) return;
    
    // if already active, prevent default and stop
    if (item.classList.contains(this.activeClass)) {
      event.preventDefault();
      return;
    }
    
    // ✅ ใช้ Smart URL Matcher ในการตรวจสอบ current path
    const currentPath = window.location.pathname;
    if (this._isNavLinkActive(destination, currentPath)) {
      event.preventDefault();
      return;
    }

    // ✅ DEV MODE: ใน localhost ให้ navigate ตรงๆ ไม่ต้องลอง candidates
    if (this._isDevMode) {
      // ปล่อยให้ default behavior ทำงาน (ไม่ต้อง preventDefault)
      return;
    }

    // Intercept navigation and attempt aggressive language-aware resolution
    // Prevent default and try candidates; if fails, fallback to original href
    event.preventDefault();
    (async () => {
      const did = await this._tryNavigateCandidates(destination, event);
      if (!did) {
        // fallback: navigate to link.href (which was pre-generated to include prefix if possible)
        try {
          const linkEl = event.target.closest('a[href]');
          if (linkEl) window.location.assign(linkEl.href);
        } catch (e) {
          // final fallback
          try { location.href = destination; } catch (e2) {}
        }
      }
    })();
  }

  /* --- active state updates (rAF-friendly) --- */
  _onScrollForActiveState(){
    if (this._rafId == null){
      this._rafId = window.requestAnimationFrame(() => {
        this._updateActiveState();
        this._rafId = null;
      });
    }
  }

  _updateActiveState(){
    if (!this._navEl) return;
    const currentPath = window.location.pathname;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    
    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const navLink = it.dataset.link || it.dataset.goUrl || '';
      
      // ✅ ใช้ Smart URL Matcher แทนการเปรียบเทียบตรงๆ
      const shouldBeActive = this._isNavLinkActive(navLink, currentPath);
      
      const wasActive = it.classList.contains(this.activeClass);
      it.classList.toggle(this.activeClass, shouldBeActive);
      
      // ✅ เริ่มอนิเมชั่นถ้าเพิ่ง active
      const wrapper = it.querySelector('.svg-wrapper');
      if (!wrapper) continue;
      
      if (shouldBeActive && !wasActive) {
        // remove class ก่อนเพื่อรีสตาร์ท animation
        wrapper.classList.remove('animate');
        // force reflow เพื่อให้ animation retrigger
        void wrapper.offsetWidth;
        wrapper.classList.add('animate');
      }
    }
  }

  /* --- ✅ Update all navigation URLs when language changes --- */
  _updateAllNavUrls(){
    if (!this._navEl) return;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    
    for (let i = 0; i < items.length; i++){
      const item = items[i];
      const baseUrl = item.dataset.goUrl || item.dataset.link;
      if (!baseUrl) continue;
      
      // ข้าม external links
      if (item.dataset.isExternal === 'true') continue;
      
      // สร้าง URL ใหม่ด้วย language prefix ปัจจุบัน
      const newUrl = this._generateNavUrl(baseUrl);
      
      // ✅ FIXED: อัพเดท href ให้ตรงกับภาษาปัจจุบัน
      if (item.href !== newUrl) {
        item.href = newUrl;
      }
    }
  }

  /* --- language / label updates --- */
  _onSelectedLangChange(val){
    const newLang = val || this.defaultLang;
    if (this.currentLang === newLang) return;
    
    this.currentLang = newLang;
    this._updateLabels(this.currentLang);
    
    // ✅ อัปเดต URLs ทั้งหมดเมื่อเปลี่ยนภาษา
    this._updateAllNavUrls();
    
    // ✅ อัปเดต active state หลังจากเปลี่ยนภาษา (URL อาจเปลี่ยน)
    this._updateActiveState();
  }

  _updateLabels(lang){
    if (!this._navEl || !this._config?.navigation) return;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const link = it.dataset.link;
      const cfg = this._config.navigation.find(n => n.url === link);
      if (cfg){
        const label = it.querySelector('.label');
        if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
      }
    }
  }

  _onStorageEvent(e){
    if (e.key === 'selectedLang') {
      this._onSelectedLangChange(e.newValue);
      // ✅ FIXED: ซิงค์ URL เมื่อภาษาเปลี่ยนจาก tab อื่น
      this._syncNavUrlsWithCurrentLanguage();
    }
  }

  /* --- ✅ External hide/show command handler --- */
  _onExternalCommand(event){
    const cmd = event?.detail?.command;
    const reason = event?.detail?.reason || 'unknown';
    
    if (cmd === 'hide') {
      this.hideNav(reason);
    } else if (cmd === 'show' || cmd === 'restore') {
      this.showNav(reason);
    } else if (cmd === 'toggle') {
      if (this._externalHideRequested || !this._navVisible) {
        this.showNav(reason);
      } else {
        this.hideNav(reason);
      }
    }
  }

  /* --- ✅ Public API: hide/show navigation from external systems --- */
  /**
   * Hide navigation bar
   * @param {string} reason - Optional reason for hiding (for logging/tracking)
   */
  hideNav(reason = 'external') {
    if (!this._navEl) return;
    this._externalHideRequested = true;
    this._autoScrollSyncEnabled = false;
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navVisible = false;
    console.log(`[ModernNav] Navigation hidden (${reason})`);
    this._dispatchNavStateEvent('hidden', reason);
  }

  /**
   * Show/restore navigation bar and resume auto scroll-sync
   * @param {string} reason - Optional reason for showing (for logging/tracking)
   */
  showNav(reason = 'external') {
    if (!this._navEl) return;
    this._externalHideRequested = false;
    this._autoScrollSyncEnabled = true;
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navVisible = true;
    console.log(`[ModernNav] Navigation shown (${reason})`);
    this._dispatchNavStateEvent('shown', reason);
  }

  /**
   * Toggle navigation visibility
   * @param {string} reason - Optional reason for toggle
   */
  toggleNav(reason = 'external') {
    if (this._externalHideRequested || !this._navVisible) {
      this.showNav(reason);
    } else {
      this.hideNav(reason);
    }
  }

  /**
   * Check if navigation is currently visible
   * @returns {boolean}
   */
  isNavVisible() {
    return this._navVisible && !this._externalHideRequested;
  }

  /* --- ✅ Dispatch custom event for external listeners --- */
  _dispatchNavStateEvent(state, reason) {
    const event = new CustomEvent('modernNavStateChanged', {
      detail: { state, reason, visible: this._navVisible }
    });
    window.dispatchEvent(event);
  }

  /* --- screen behavior: mount/unmount left-rail and mobile scroll sync --- */
  _isMobileScreen(){
    return window.innerWidth < 768;
  }

  _applyScreenBehavior(){
    const isMobile = this._isMobileScreen();

    // keep nav class in sync (CSS can also read it)
    if (this._navEl) this._navEl.classList.toggle('vertical', !isMobile);

    if (isMobile){
      // mobile: ensure unmounted and enable scroll sync
      this._unmountLeftRailIfMounted();
      this._enableScrollNavSync();
    } else {
      // tablet/desktop: mount left-rail and disable mobile scroll sync
      this._mountLeftRailIfNeeded();
      this._disableScrollNavSync();
    }
  }

  _mountLeftRailIfNeeded() {
    if (!this._navEl) return;
    if (document.body.classList.contains('has-left-rail')) return;
    
    const nav = this._navEl;
    const siteMain = document.createElement('div');
    siteMain.className = 'site-main';
    
    // ย้าย children ทั้งหมดของ body ยกเว้น nav ไปใน site-main
    const nodes = Array.from(document.body.childNodes);
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node === nav) continue;
      siteMain.appendChild(node);
    }
    document.body.appendChild(siteMain);
    document.body.classList.add('has-left-rail');
    
    // sync CSS vars
    document.documentElement.style.setProperty('--left-rail-width', this.leftRailWidth);
    document.documentElement.style.setProperty('--left-rail-collapsed-width', this.leftRailCollapsedWidth);
    
    // ตั้งค่า nav ให้ fixed บนหน้าจอแทน sticky เพื่อหลีกเลี่ยงช่องว่างด้านล่าง
    nav.style.position = 'fixed';
    nav.style.top = '0';
    nav.style.left = '0';
    nav.style.transform = 'none';
    nav.style.zIndex = '1000';
    // ให้เต็มความสูงของ viewport โดยใช้ 100vh (ไม่ต้องใช้ ResizeObserver)
    nav.style.height = '100vh';
    nav.style.overflow = 'auto';

    // ปรับเนื้อหาให้มีระยะซ้ายพอสำหรับ left rail
    // ใช้ fixed width ที่กำหนดใน config (this.leftRailWidth)
    siteMain.style.marginLeft = this.leftRailWidth;
  }

  _unmountLeftRailIfMounted(){
    if (!this._navEl) return;
    if (!document.body.classList.contains('has-left-rail')) return;
    const nav = this._navEl;
    const siteMain = document.querySelector('.site-main');
    if (siteMain){
      const children = Array.from(siteMain.childNodes);
      // insert before siteMain to preserve approximate order (nav is first)
      for (let i = 0; i < children.length; i++) {
        document.body.insertBefore(children[i], siteMain);
      }
      // remove siteMain
      if (siteMain.parentNode) siteMain.parentNode.removeChild(siteMain);
    }
    document.body.classList.remove('has-left-rail');
    // remove CSS vars
    document.documentElement.style.removeProperty('--left-rail-width');
    document.documentElement.style.removeProperty('--left-rail-collapsed-width');

    // restore nav to mobile defaults
    nav.style.position = '';
    nav.style.top = '';
    nav.style.height = '';
    nav.style.left = '';
    nav.style.transform = '';
    nav.style.zIndex = '16000';
    nav.style.overflow = '';

    // remove margin-left set on siteMain (if it exists)
    // (siteMain removed already, but in case any leftover style exists on body children, we clear)
    const bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach((el) => {
      if (el.style && el.style.marginLeft === this.leftRailWidth) {
        el.style.marginLeft = '';
      }
    });
  }

  /* --- mobile scroll sync (hide-on-scroll) --- */
  _enableScrollNavSync(){
    if (this._navScrollSyncEnabled) return;
    // bind handlers
    window.addEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.addEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.addEventListener('touchend', this._onTouchEndBound, { passive: true });
    // ensure nav visible (unless externally hidden)
    if (this._navEl && !this._externalHideRequested){
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = true;
  }

  _disableScrollNavSync(){
    if (!this._navScrollSyncEnabled) return;
    window.removeEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.removeEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.removeEventListener('touchend', this._onTouchEndBound, { passive: true });
    // ensure visible
    if (this._navEl && !this._externalHideRequested){
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = false;
  }

  _onTouchStart(){
    this._isTouching = true;
    this._lastScrollY = window.scrollY;
  }
  _onTouchEnd(){
    this._isTouching = false;
  }

  _onUltraScrollNav(){
    // ✅ ไม่ทำการซ่อน/แสดงอัตโนมัติถ้า external ขอให้ซ่อนไว้
    if (this._externalHideRequested || !this._autoScrollSyncEnabled) return;
    
    if (!this._navEl) return;
    const y = window.scrollY;
    const delta = y - this._lastScrollY;
    this._lastScrollY = y;
    if (y <= this.SHOW_THRESHOLD){
      if (!this._navVisible) this._showNav();
      return;
    }
    if (this._isTouching){
      if (delta > 15 && this._navVisible) this._hideNav();
      else if (delta < -10 && !this._navVisible) this._showNav();
    }
  }

  _hideNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navVisible = false;
  }
  _showNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navVisible = true;
  }

  /* --- utilities --- */
  _debounce(fn, wait = 100){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  /* cleanup / destroy */
  _cleanup(){
    try {
      // remove event listeners we explicitly added
      window.removeEventListener('resize', this._resizeHandler, { passive: true });
      window.removeEventListener('orientationchange', this._orientationHandler, { passive: true });
      window.removeEventListener('scroll', this._scrollHandler, { passive: true });
      window.removeEventListener('storage', this._storageHandler, { passive: true });
      
      // ✅ FIXED: ลบ popstate handler ที่ถูกต้อง
      window.removeEventListener('popstate', this._popStateHandlerBound);
      
      window.removeEventListener('modernNavCommand', this._onExternalCommandBound);
      // remove mobile-sync if active
      this._disableScrollNavSync();
      // restore localStorage.setItem if we had overridden it (we didn't)
      // close BroadcastChannel
      if (this._bc) try { this._bc.close(); } catch(e){}
    } catch(e){
      // swallow errors during cleanup
    }
    this._initialized = false;
    this._navEl = null;
  }

  destroy(){
    this._cleanup();
  }
}

/* bootstrap */
(function(){
  const nav = new ModernNavigation({
    cssPath: '/assets/css/modern-styles.min.css',
    configPath: '/assets/json/template/template.min.json',
    defaultButtonClass: 'default-button',
    leftRailWidth: '88px',
    leftRailCollapsedWidth: '72px',
    // ✅ สามารถเพิ่มรหัสภาษาที่รองรับได้ที่นี่ (optional)
    supportedLangCodes: ['th', 'en', 'ja', 'ko', 'zh', 'fr', 'de', 'es', 'it', 'pt', 'ru', 'ar', 'vi', 'id', 'ms', 'tl'],
    // ✅ forceLangPrefix จะถูก override เป็น false อัตโนมัติใน dev mode
    forceLangPrefix: true
  });
  queueMicrotask(() => {
    nav.init().catch(e => console.error('ModernNavigation init failed:', e));
  });
  
  // ✅ Expose instance globally for external systems
  window.modernNav = nav;
})();