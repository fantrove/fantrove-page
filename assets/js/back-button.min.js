/**
 * Back Button Manager v3.0
 * ทำหน้าที่:
 * 1. จัดการการย้อนกลับพร้อมบันทึก context
 * 2. ประสานงานกับ Language Manager เพื่อคงภาษาที่ถูกต้อง
 * 3. จัดการกรณีไม่มี history
 */

(function() {
  'use strict';

  const CONFIG = {
    DELAY: 100,
    STORAGE_KEYS: {
      BACK_INTENT: 'fv-back-intent',
      NAV_CONTEXT: 'fv-nav-context',
      LAST_LANG: 'fv-last-lang',
      NAV_MAP: 'fv-nav-lang-map'
    }
  };

  // Utility: Safe storage
  const storage = {
    set(key, value) {
      try { sessionStorage.setItem(key, value); } catch(e) {}
    },
    get(key) {
      try { return sessionStorage.getItem(key); } catch(e) { return null; }
    },
    setLocal(key, value) {
      try { localStorage.setItem(key, value); } catch(e) {}
    },
    getLocal(key) {
      try { return localStorage.getItem(key); } catch(e) { return null; }
    }
  };

  // Back Navigation Handler
  class BackNavigationHandler {
    constructor() {
      this.button = document.getElementById('back-button');
      if (!this.button) {
        console.warn('[BackButton] Button not found');
        return;
      }
      
      this.attachListener();
    }

    attachListener() {
      this.button.addEventListener('click', (e) => this.handleClick(e));
    }

    handleClick(e) {
      e.preventDefault();
      
      // Mark back intent
      this.markBackIntent();
      
      // Small delay for storage to settle
      setTimeout(() => {
        this.executeBack();
      }, CONFIG.DELAY);
    }

    markBackIntent() {
      // Set flag for other scripts to detect
      storage.set(CONFIG.STORAGE_KEYS.BACK_INTENT, JSON.stringify({
        timestamp: Date.now(),
        from: location.href,
        currentLang: storage.getLocal('selectedLang')
      }));

      // Set navigation context
      storage.set(CONFIG.STORAGE_KEYS.NAV_CONTEXT, JSON.stringify({
        type: 'back_forward',
        timestamp: Date.now(),
        source: 'back_button'
      }));
    }

    executeBack() {
      if (window.history.length > 1) {
        // Check if we have language mapping for previous page
        const prevLang = this.detectPreviousPageLanguage();
        
        if (prevLang) {
          // Store expected language for when we land
          storage.setLocal('selectedLang', prevLang);
        }

        window.history.back();
        
        // Fallback check in case history.back() doesn't trigger navigation
        setTimeout(() => this.checkNavigationSuccess(), 300);
      } else {
        this.redirectToHome();
      }
    }

    detectPreviousPageLanguage() {
      // Try to get from navigation map
      try {
        const navMapRaw = storage.get(CONFIG.STORAGE_KEYS.NAV_MAP);
        if (navMapRaw) {
          const navMap = JSON.parse(navMapRaw);
          // Get most recent entry that's not current
          const entries = Object.entries(navMap)
            .filter(([path]) => path !== location.pathname)
            .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
          
          if (entries.length > 0) {
            return entries[0][1].lang;
          }
        }
      } catch(e) {}
      
      // Fallback to current lang (maintain consistency)
      return storage.getLocal('selectedLang');
    }

    checkNavigationSuccess() {
      // If we're still here after history.back(), something went wrong
      if (document.hasFocus && document.hasFocus()) {
        this.redirectToHome();
      }
    }

    redirectToHome() {
      const currentLang = storage.getLocal('selectedLang') || 'en';
      window.location.href = `/${currentLang}/home`;
    }
  }

  // Alternative Back Detection (for browser back button)
  class BrowserBackDetector {
    constructor() {
      this.lastUrl = location.href;
      this.init();
    }

    init() {
      // Listen for popstate
      window.addEventListener('popstate', (e) => this.handlePopState(e));
      
      // Periodic check for hash changes or manual URL edits
      setInterval(() => {
        if (location.href !== this.lastUrl) {
          this.lastUrl = location.href;
          this.handleUrlChange();
        }
      }, 100);
    }

    handlePopState(e) {
      // This is a back/forward navigation
      storage.set(CONFIG.STORAGE_KEYS.NAV_CONTEXT, JSON.stringify({
        type: 'back_forward',
        timestamp: Date.now(),
        source: 'browser_button',
        state: e.state
      }));

      // Dispatch event for other scripts
      window.dispatchEvent(new CustomEvent('fv:backNavigation', {
        detail: { state: e.state, url: location.href }
      }));
    }

    handleUrlChange() {
      // Additional handling if needed
    }
  }

  // Initialize
  function init() {
    new BackNavigationHandler();
    new BrowserBackDetector();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
