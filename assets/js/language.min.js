/**
 * LanguageManager Ultra-Enterprise: State-Machine Edition
 * หลักการทำงานใหม่:
 * 1. URL เปลี่ยนก่อนเสมอ (replaceState/pushState ก่อน update content)
 * 2. History State เป็นแหล่งข้อมูลหลัก (ไม่ใช่ localStorage อย่างเดียว)
 * 3. Popstate อ่านจาก event.state เป็นหลัก ไม่ใช่แค่ดู URL
 * 4. ระบบจำลอง state ล่วงหน้า (predictive) เพื่อให้ back/forward ลื่นไหล
 */

//////////////////// IndexedDB Utilities ////////////////////
const DB_NAME = "LanguageCacheDB_v2"; // bump version สำหรับ breaking change
const DB_STORE = "langs";
const DB_META = "meta";
const DB_STATE = "state_history"; // ใหม่: เก็บ state snapshot
const DB_VERSION = 4;

function openLangDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onerror = () => reject(req.error);
    req.onupgradeneeded = (ev) => {
      const db = req.result;
      if (!db.objectStoreNames.contains(DB_STORE)) {
        db.createObjectStore(DB_STORE, { keyPath: "key" });
      }
      if (!db.objectStoreNames.contains(DB_META)) {
        db.createObjectStore(DB_META, { keyPath: "key" });
      }
      if (!db.objectStoreNames.contains(DB_STATE)) {
        const store = db.createObjectStore(DB_STATE, { keyPath: "id", autoIncrement: true });
        store.createIndex("timestamp", "timestamp", { unique: false });
        store.createIndex("session", "sessionId", { unique: false });
      }
    };
    req.onsuccess = () => resolve(req.result);
  });
}

async function saveStateSnapshot(state) {
  const db = await openLangDB();
  const sessionId = getSessionId();
  return new Promise((resolve) => {
    const tx = db.transaction(DB_STATE, "readwrite");
    const store = tx.objectStore(DB_STATE);
    // เก็บแค่ 50 states ล่าสุดต่อ session
    store.put({ ...state, sessionId, timestamp: Date.now() });
    // cleanup เก่า
    const idx = store.index("session");
    const range = IDBKeyRange.only(sessionId);
    const req = idx.openCursor(range);
    let count = 0;
    const toDelete = [];
    req.onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor) {
        count++;
        if (count > 50) toDelete.push(cursor.primaryKey);
        cursor.continue();
      } else {
        toDelete.forEach(key => store.delete(key));
      }
    };
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

function getSessionId() {
  let sid = sessionStorage.getItem('lm_session_id');
  if (!sid) {
    sid = 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
    sessionStorage.setItem('lm_session_id', sid);
  }
  return sid;
}

async function getLangCacheBatch(langKeys) {
  const db = await openLangDB();
  return await Promise.all(langKeys.map(langKey => {
    return new Promise(resolve => {
      const tx = db.transaction(DB_STORE, "readonly");
      const store = tx.objectStore(DB_STORE);
      const req = store.get(langKey);
      req.onsuccess = () => resolve(req.result ? req.result.data : null);
      req.onerror = () => resolve(null);
    });
  }));
}

async function setLangCacheBatch(langDatas) {
  const db = await openLangDB();
  return await Promise.all(langDatas.map(({ langKey, data }) => {
    return new Promise(resolve => {
      const tx = db.transaction(DB_STORE, "readwrite");
      const store = tx.objectStore(DB_STORE);
      store.put({ key: langKey, data, ts: Date.now() });
      tx.oncomplete = () => resolve();
      tx.onerror = () => resolve();
    });
  }));
}

async function getMeta(key) {
  const db = await openLangDB();
  return new Promise(resolve => {
    const tx = db.transaction(DB_META, "readonly");
    const store = tx.objectStore(DB_META);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result ? req.result.value : null);
    req.onerror = () => resolve(null);
  });
}

async function setMeta(key, value) {
  const db = await openLangDB();
  return new Promise(resolve => {
    const tx = db.transaction(DB_META, "readwrite");
    const store = tx.objectStore(DB_META);
    store.put({ key, value });
    tx.oncomplete = () => resolve();
    tx.onerror = () => resolve();
  });
}

//////////////////// Worker Pool ////////////////////
class WorkerPool {
  constructor(workerCode, poolSize) {
    this.workers = [];
    this.idle = [];
    this.jobs = [];
    for (let i = 0; i < poolSize; ++i) {
      const blob = new Blob([workerCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      const worker = new Worker(url);
      worker.onmessage = (e) => this._onMessage(worker, e);
      this.workers.push(worker);
      this.idle.push(worker);
    }
    this.jobMap = new Map();
  }
  execute(data) {
    return new Promise((resolve, reject) => {
      const job = { data, resolve, reject };
      if (this.idle.length > 0) {
        const worker = this.idle.pop();
        this._runJob(worker, job);
      } else {
        this.jobs.push(job);
      }
    });
  }
  _runJob(worker, job) {
    this.jobMap.set(worker, job);
    worker.postMessage(job.data);
  }
  _onMessage(worker, e) {
    const job = this.jobMap.get(worker);
    this.jobMap.delete(worker);
    job.resolve(e.data);
    this.idle.push(worker);
    if (this.jobs.length > 0) {
      const nextJob = this.jobs.shift();
      this._runJob(worker, nextJob);
    }
  }
  destroy() {
    this.workers.forEach(w => w.terminate && w.terminate());
    this.workers = [];
    this.idle = [];
    this.jobs = [];
    this.jobMap.clear();
  }
}

//////////////////// Main LanguageManager ////////////////////
class LanguageManager {
  constructor() {
    this.languagesConfig = {};
    this.selectedLang = "";
    this.lastSelectedLang = "";
    this.isLanguageDropdownOpen = false;
    this.languageCache = {};
    this.isUpdatingLanguage = false;
    this.isNavigating = false;
    this.mutationObserver = null;
    this.scrollPosition = 0;
    this.isInitialized = false;
    this.mutationThrottleTimeout = null;
    this.FADE_DURATION = 300;

    // ใหม่: State Management
    this._stateVersion = 0; // increment ทุกครั้งที่เปลี่ยนภาษา
    this._navigationStack = []; // จำลอง stack สำหรับตรวจสอบ direction
    this._processingPopstate = false; // lock ป้องกัน recursive
    
    this.maxWorker = navigator.hardwareConcurrency ? Math.max(4, Math.floor(navigator.hardwareConcurrency * 0.9)) : 8;
    
    const workerCode = `
      function splitMarkersAndHtml(str) {
        const htmlSplit = str.split(/(<\\/?.+?>)/g);
        const parts = [];
        const markerRegex = /(@lsvg(?::([^@]+))?@)|(@svg(?::([^@]+))?@)|(@slot:([^@]+)@)|(@a(.*?)@)|(@br)|(@strong(.*?)@)/g;
        for (let segment of htmlSplit) {
          if (!segment) continue;
          if (/^<\\/?.+?>$/.test(segment)) {
            parts.push({ type: 'html', html: segment });
          } else {
            let lastIndex = 0;
            let m;
            while ((m = markerRegex.exec(segment)) !== null) {
              if (m.index > lastIndex) {
                parts.push({ type: 'text', text: segment.slice(lastIndex, m.index) });
              }
              if (m[1]) {
                const id = m[2] || null;
                parts.push({ type: 'lsvg', id });
              } else if (m[3]) {
                const id = m[4] || null;
                parts.push({ type: 'svg', id });
              } else if (m[5]) {
                const name = m[6] || null;
                parts.push({ type: 'slot', name });
              } else if (m[7]) {
                const inner = m[8] || '';
                parts.push({ type: 'a', translate: inner !== "", text: inner });
              } else if (m[9]) {
                parts.push({ type: 'br' });
              } else if (m[10]) {
                const s = m[11] || '';
                parts.push({ type: 'strong', text: s });
              }
              lastIndex = markerRegex.lastIndex;
            }
            if (lastIndex < segment.length) {
              parts.push({ type: 'text', text: segment.slice(lastIndex) });
            }
          }
        }
        return parts;
      }
      self.onmessage = function(e) {
        const { nodes, langData, batchIdx } = e.data;
        const result = [];
        for (let i=0;i<nodes.length;i++) {
          const { key } = nodes[i];
          let translation = langData[key] || '';
          let parts = splitMarkersAndHtml(translation);
          result.push({ idx: i, parts });
        }
        self.postMessage({ batchIdx, result });
      };
    `;
    this.workerPool = new WorkerPool(workerCode, this.maxWorker);

    this._prefetchPromise = this.prefetchEnterprise();

    this.enforcePathLangPrefix = true;

    // BroadcastChannel สำหรับ cross-tab sync
    try { 
      this._bc = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('fv-lang-v2') : null; 
    } catch (e) { 
      this._bc = null; 
    }
    if (this._bc) {
      this._bc.onmessage = (ev) => this._onBroadcastLang(ev.data);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => this.initialize());
    } else {
      this.initialize();
    }
  }

  getEnSource() {
    if (this.languagesConfig && this.languagesConfig.en && typeof this.languagesConfig.en.enSource !== "undefined") {
      return this.languagesConfig.en.enSource === "json" ? "json" : "html";
    }
    return "html";
  }

  // ใหม่: State Version Management
  _getCurrentState() {
    return {
      language: this.selectedLang,
      lastLanguage: this.lastSelectedLang,
      version: this._stateVersion,
      timestamp: Date.now(),
      url: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      hash: window.location.hash
    };
  }

  _incrementVersion() {
    this._stateVersion++;
    try {
      localStorage.setItem('lm_state_version', String(this._stateVersion));
      localStorage.setItem('lm_selected_lang', this.selectedLang);
      localStorage.setItem('lm_last_lang', this.lastSelectedLang);
      localStorage.setItem('lm_last_update', String(Date.now()));
    } catch (e) {}
    return this._stateVersion;
  }

  _readStoredState() {
    try {
      return {
        version: parseInt(localStorage.getItem('lm_state_version') || '0', 10),
        lang: localStorage.getItem('lm_selected_lang') || 'en',
        lastLang: localStorage.getItem('lm_last_lang') || 'en',
        lastUpdate: parseInt(localStorage.getItem('lm_last_update') || '0', 10)
      };
    } catch (e) {
      return { version: 0, lang: 'en', lastLang: 'en', lastUpdate: 0 };
    }
  }

  async _onBroadcastLang(msg) {
    if (!msg || typeof msg !== 'object') return;
    
    // ไม่ประมวลผลถ้ากำลังประมวลผล popstate อยู่
    if (this._processingPopstate) return;
    
    const { type, state, source } = msg;
    
    // ไม่ตอบสนองต่อข้อความจากตัวเอง (ยกเว้นกรณีพิเศษ)
    if (source === getSessionId() && type !== 'force_sync') return;
    
    if (type === 'lang_change' && state) {
      const stored = this._readStoredState();
      
      // ตรวจสอบว่า state ที่ได้รับใหม่กว่าของเราหรือไม่
      if (state.version > this._stateVersion || 
          (state.version === this._stateVersion && state.timestamp > stored.lastUpdate)) {
        
        // อัพเดต state ของเราให้ตรงกับ broadcast
        this._stateVersion = state.version;
        
        // ถ้าภาษาเปลี่ยน ให้ update โดยไม่เปลี่ยน URL (เพราะอีก tab เปลี่ยนแล้ว)
        if (state.language !== this.selectedLang) {
          await this._applyLanguageChange(state.language, { 
            updateHistory: false, 
            broadcast: false, // ไม่ broadcast ซ้ำ
            fromBroadcast: true 
          });
        }
      }
    } else if (type === 'request_sync') {
      // ตอบกลับด้วย state ปัจจุบัน
      this._broadcastState('sync_response');
    }
  }

  _broadcastState(type = 'lang_change', force = false) {
    if (!this._bc) return;
    
    const state = this._getCurrentState();
    const msg = {
      type,
      state,
      source: getSessionId(),
      force
    };
    
    try {
      this._bc.postMessage(msg);
    } catch (e) {}
  }

  async prefetchEnterprise() {
    if (typeof document !== "undefined" && document.head) {
      ["//cdn.jsdelivr.net", "//fonts.googleapis.com"].forEach(href => {
        if (!document.head.querySelector(`link[href^="${href}"]`)) {
          const l = document.createElement("link");
          l.rel = "preconnect";
          l.href = href;
          l.crossOrigin = "anonymous";
          document.head.appendChild(l);
        }
      });
    }
    
    let config = null;
    const localConfigRaw = localStorage.getItem('__lang_cfg');
    const sessionConfigRaw = sessionStorage.getItem('__lang_cfg');
    
    if (localConfigRaw) try { config = JSON.parse(localConfigRaw); } catch {}
    if (!config && sessionConfigRaw) try { config = JSON.parse(sessionConfigRaw); } catch {}

    const url = '/assets/lang/options/db.min.json';
    const metaKey = 'langcfg';
    let needUpdate = true;
    
    if (config) {
      try {
        const headResp = await fetch(url, { method: "HEAD" });
        let etag = headResp.headers.get('ETag');
        let version = headResp.headers.get('X-Version');
        let hash = headResp.headers.get('X-Hash');
        let cachedETag = await getMeta(metaKey + ":etag");
        let cachedHash = await getMeta(metaKey + ":hash");
        let cachedVersion = await getMeta(metaKey + ":version");
        if ((etag && etag === cachedETag) || (version && version === cachedVersion) || (hash && hash === cachedHash)) {
          needUpdate = false;
        }
      } catch (e) {}
    }
    
    if (needUpdate) {
      let result = await this.fetchWithEtagOrHash(url, '__lang_cfg', metaKey);
      if (result.updated && result.body) {
        config = JSON.parse(result.body);
        localStorage.setItem('__lang_cfg', JSON.stringify(config));
        sessionStorage.setItem('__lang_cfg', JSON.stringify(config));
      } else if (!config) {
        config = await fetch(url).then(r => r.json()).catch(() => null);
        if (config) {
          localStorage.setItem('__lang_cfg', JSON.stringify(config));
          sessionStorage.setItem('__lang_cfg', JSON.stringify(config));
        }
      }
    }
    
    if (config) {
      this.languagesConfig = config;
    }
    this.prepareAllButtonTexts();
  }

  async fetchWithEtagOrHash(url, cacheKey, metaKey) {
    let cachedETag = await getMeta(metaKey + ":etag");
    let cachedHash = await getMeta(metaKey + ":hash");
    let cachedVersion = await getMeta(metaKey + ":version");
    let headers = {};
    if (cachedETag) headers['If-None-Match'] = cachedETag;
    
    let resp = await fetch(url, {
      headers,
      cache: "reload",
      priority: "high"
    });
    
    if (resp.status === 304) {
      return { updated: false };
    }
    
    let etag = resp.headers.get('ETag');
    let version = resp.headers.get('X-Version');
    let hash = resp.headers.get('X-Hash');
    let text = await resp.text();
    let body = text;
    let hashValue = hash;
    
    if (!hash && window.crypto && window.crypto.subtle) {
      const buf = new TextEncoder().encode(body);
      hashValue = await window.crypto.subtle.digest('SHA-256', buf)
        .then(hashBuf => Array.from(new Uint8Array(hashBuf)).map(x => x.toString(16).padStart(2, '0')).join(''));
    }
    
    if ((etag && etag === cachedETag) || (version && version === cachedVersion) || (hashValue && hashValue === cachedHash)) {
      return { updated: false };
    }
    
    if (etag) await setMeta(metaKey + ":etag", etag);
    if (hashValue) await setMeta(metaKey + ":hash", hashValue);
    if (version) await setMeta(metaKey + ":version", version);
    
    return { updated: true, body, etag, version, hash: hashValue };
  }

  async enterpriseLoadLang(lang) {
    if (this.languageCache[lang]) return this.languageCache[lang];

    const langKey = lang + "_v1";
    const metaKey = "lang_" + lang;
    let cacheData = await getLangCacheBatch([langKey]).then(resArr => resArr[0]);

    const url = `/assets/lang/${lang}.min.json`;
    let needUpdate = true;
    
    if (cacheData) {
      try {
        const headResp = await fetch(url, { method: "HEAD" });
        let etag = headResp.headers.get('ETag');
        let version = headResp.headers.get('X-Version');
        let hash = headResp.headers.get('X-Hash');
        let cachedETag = await getMeta(metaKey + ":etag");
        let cachedHash = await getMeta(metaKey + ":hash");
        let cachedVersion = await getMeta(metaKey + ":version");
        if ((etag && etag === cachedETag) || (version && version === cachedVersion) || (hash && hash === cachedHash)) {
          needUpdate = false;
        }
      } catch (e) {}
    }
    
    let data = cacheData;
    if (needUpdate) {
      let result = await this.fetchWithEtagOrHash(url, langKey, metaKey);
      if (result.updated && result.body) {
        data = this.flattenLanguageJson(JSON.parse(result.body));
        await setLangCacheBatch([{ langKey, data }]);
      } else if (!data) {
        data = await fetch(url).then(r => r.json()).then(obj => this.flattenLanguageJson(obj)).catch(() => null);
        if (data) await setLangCacheBatch([{ langKey, data }]);
      }
    }
    
    if (data) this.languageCache[lang] = data;
    return data;
  }

  flattenLanguageJson(json) {
    const result = {};
    function recur(obj) {
      for (const [k, v] of Object.entries(obj)) {
        if (typeof v === 'object' && v !== null) recur(v);
        else result[k] = v;
      }
    }
    recur(json);
    return result;
  }

  async prepareAllButtonTexts() {
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton || !this.languagesConfig) return;
    
    Array.from(this.languageButton.querySelectorAll('.lang-btn-txt, .lang-btn-svg')).forEach(e => e.remove());

    let flexWrap = this.languageButton.querySelector('.lang-btn-flex');
    if (!flexWrap) {
      flexWrap = document.createElement('span');
      flexWrap.className = 'lang-btn-flex';
      flexWrap.style.display = 'inline-flex';
      flexWrap.style.alignItems = 'center';
      flexWrap.style.gap = '15px';
      flexWrap.style.verticalAlign = 'middle';
      while (this.languageButton.firstChild) this.languageButton.removeChild(this.languageButton.firstChild);
      this.languageButton.appendChild(flexWrap);
    } else {
      flexWrap.innerHTML = '';
    }

    const svgWrap = document.createElement('span');
    svgWrap.className = 'lang-btn-svg';
    svgWrap.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18.5" height="18.5" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"><path d="M4 5h7" /><path d="M9 3v2c0 4.418 -2.239 8 -5 8" /><path d="M5 9c0 2.144 2.952 3.908 6.7 4" /><path d="M12 20l4 -9l4 9" /><path d="M19.1 18h-6.2" /></svg>`;
    svgWrap.style.display = 'inline-flex';
    svgWrap.style.alignItems = 'center';
    svgWrap.style.justifyContent = 'center';

    flexWrap.appendChild(svgWrap);

    Object.entries(this.languagesConfig).forEach(([lang, config]) => {
      const span = document.createElement('span');
      span.className = 'lang-btn-txt';
      span.dataset.lang = lang;
      span.textContent = config.buttonText || 'Language';
      span.style.display = 'none';
      span.style.lineHeight = '1';
      flexWrap.appendChild(span);
    });
    
    this.showButtonTextForLang(this.selectedLang || 'en');
  }

  showButtonTextForLang(lang) {
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton) return;
    const flexWrap = this.languageButton.querySelector('.lang-btn-flex');
    if (!flexWrap) return;
    Array.from(flexWrap.querySelectorAll('.lang-btn-txt')).forEach(span => {
      span.style.display = (span.dataset.lang === lang) ? '' : 'none';
    });
  }

  updateLanguageSelectorUI() { 
    this.initializeCustomLanguageSelector(); 
  }

  detectBrowserLanguage() {
    if (!this.languagesConfig) return 'en';
    const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage];
    for (const lang of browserLanguages) {
      const langCode = lang.split('-')[0];
      if (this.languagesConfig[langCode]) return langCode;
    }
    return 'en';
  }

  _pathHasLangPrefix(path) {
    if (!path) path = window.location.pathname || '/';
    try {
      const codes = Object.keys(this.languagesConfig || {}).map(k => k.replace(/[^a-zA-Z]/g,'')).filter(Boolean);
      if (!codes.length) return /^\/(en|th)(\/|$)/.test(path);
      const alt = codes.join('|');
      const re = new RegExp('^\\/(' + alt + ')(\\/|$)', 'i');
      return re.test(path);
    } catch (e) {
      return /^\/(en|th)(\/|$)/.test(path);
    }
  }

  _prefixPathWithLang(path, lang) {
    if (!path) path = '/';
    if (!path.startsWith('/')) path = '/' + path;
    
    // ถ้ามี prefix อยู่แล้ว ให้แทนที่
    if (this._pathHasLangPrefix(path)) {
      return path.replace(/^\/[^\/]+/, '/' + lang);
    }
    
    if (path === '/' || path === '') return '/' + lang + '/';
    return '/' + lang + (path.startsWith('/') ? path : '/' + path);
  }

  _removeLangPrefix(path) {
    if (!path) return '/';
    const codes = Object.keys(this.languagesConfig || {}).map(k => k.replace(/[^a-zA-Z]/g,'')).filter(Boolean);
    if (!codes.length) {
      return path.replace(/^\/(en|th)(\/|$)/, '/');
    }
    const pattern = '^\\/(' + codes.join('|') + ')(\\/|$)';
    const re = new RegExp(pattern, 'i');
    return path.replace(re, '/');
  }

  _isLocalDev() {
    try {
      const host = location.hostname || '';
      if (!host) return false;
      if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return true;
      if (host.endsWith('.local')) return true;
      if (location.port && ['3000','5173','7700','8080','3001'].includes(String(location.port))) return true;
      return false;
    } catch (e) { 
      return false; 
    }
  }

  _langFromPath(path) {
    try {
      const p = path || window.location.pathname || '/';
      const m = p.match(/^\/([a-z]{2})(\/|$)/i);
      if (m) {
        const code = m[1].toLowerCase();
        if (this.languagesConfig && this.languagesConfig[code]) return code;
      }
    } catch (e) {}
    return null;
  }

  // ใหม่: สร้าง URL ที่ถูกต้องสำหรับภาษา
  _buildLanguageUrl(lang, currentUrl = null) {
    const url = currentUrl ? new URL(currentUrl) : new URL(window.location.href);
    let path = url.pathname;
    
    if (lang === 'en') {
      // ภาษาอังกฤษ = ไม่มี prefix (หรือลบออกถ้ามี)
      path = this._removeLangPrefix(path);
    } else {
      // ภาษาอื่น = ต้องมี prefix
      if (!this._pathHasLangPrefix(path)) {
        path = this._prefixPathWithLang(path, lang);
      } else {
        // แทนที่ prefix เดิม
        path = this._prefixPathWithLang(path, lang);
      }
    }
    
    url.pathname = path;
    return url;
  }

  async handleInitialLanguage() {
    this.storeOriginalContent();
    
    // อ่าน state จากหลายแหล่ง ตามลำดับ priority
    const urlParams = new URLSearchParams(window.location.search);
    const langFromQuery = urlParams.get('lang');
    const langFromPath = this._langFromPath(window.location.pathname);
    const stored = this._readStoredState();
    const historyState = history.state || {};
    
    let autoLang = this.detectBrowserLanguage();
    
    // Priority: 
    // 1. History State (ถ้ามีและไม่เก่าเกินไป)
    // 2. URL Path Prefix
    // 3. URL Query Param
    // 4. Stored Language (ถ้า version ตรงกัน)
    // 5. Browser Detection
    
    let selectedLang;
    let stateSource = 'default';
    
    if (historyState.language && historyState.timestamp && (Date.now() - historyState.timestamp < 300000)) {
      // History state ไม่เก่าเกิน 5 นาที
      selectedLang = historyState.language;
      this._stateVersion = historyState.version || stored.version || 0;
      stateSource = 'history';
    } else if (langFromPath && this.languagesConfig[langFromPath]) {
      selectedLang = langFromPath;
      this._stateVersion = stored.version || 0;
      stateSource = 'path';
    } else if (langFromQuery && this.languagesConfig[langFromQuery]) {
      selectedLang = langFromQuery;
      this._stateVersion = stored.version || 0;
      stateSource = 'query';
    } else if (stored.lang && this.languagesConfig[stored.lang] && stored.version > 0) {
      selectedLang = stored.lang;
      this._stateVersion = stored.version;
      stateSource = 'storage';
    } else {
      selectedLang = this.languagesConfig[autoLang] ? autoLang : 'en';
      this._stateVersion = 0;
      stateSource = 'browser';
    }
    
    this.selectedLang = selectedLang;
    this.lastSelectedLang = historyState.lastLanguage || stored.lastLang || 'en';
    
    // ถ้า enforcePathLangPrefix และ path ไม่ตรงกับภาษา (และไม่ใช่ dev)
    if (this.enforcePathLangPrefix && !this._isLocalDev()) {
      const expectedPath = this._buildLanguageUrl(selectedLang).pathname;
      const currentPath = window.location.pathname;
      
      if (expectedPath !== currentPath) {
        // ต้อง redirect ไป URL ที่ถูกต้อง
        const correctUrl = this._buildLanguageUrl(selectedLang);
        // ใช้ replaceState แทน redirect เพื่อไม่สร้าง history entry เกิน
        history.replaceState(this._getCurrentState(), '', correctUrl.toString());
      }
    }
    
    this.showButtonTextForLang(this.selectedLang);
    
    // โหลดภาษาเริ่มต้น
    if (this.selectedLang !== 'en' || this.getEnSource() === "json") {
      await this._applyLanguageContent(this.selectedLang);
    }
    
    console.log(`[LanguageManager] Init: ${selectedLang} (from ${stateSource}, version ${this._stateVersion})`);
  }

  async loadLanguagesConfig() {
    await this._prefetchPromise;
    if (!this.languagesConfig || !Object.keys(this.languagesConfig).length)
      throw new Error("Config ไม่ถูกต้องและโหลดใหม่ไม่ได้");
    await this.prepareAllButtonTexts();
    await this.handleInitialLanguage();
    this.updateLanguageSelectorUI();
  }

  async loadLanguageData(lang) { 
    return await this.enterpriseLoadLang(lang); 
  }

  async initialize() {
    if (this.isInitialized) return;
    try {
      await this.loadLanguagesConfig();
      this.observeMutations();
      this.setupNavigationHandlers();
      document.documentElement.setAttribute("lang", "");
      this.isInitialized = true;
      
      setTimeout(() => {
        if (document.body && document.body.style.opacity === "0") {
          document.body.style.transition = "opacity 0.28s cubic-bezier(.47,1.64,.41,.8)";
          document.body.style.opacity = "1";
        }
      }, 0);
    } catch (error) {
      console.error('Error during initialization:', error);
      this.showError('ไม่สามารถเริ่มต้นระบบได้');
      setTimeout(() => {
        if (document.body && document.body.style.opacity === "0") {
          document.body.style.opacity = "1";
        }
      }, 0);
    }
  }

  // ใหม่: Public API สำหรับเปลี่ยนภาษา (เรียกจาก UI)
  async changeLanguage(language, options = {}) {
    if (!this.languagesConfig[language]) {
      console.warn(`ไม่รองรับภาษา: ${language} กำลังใช้ภาษาอังกฤษแทน`);
      language = 'en';
    }
    
    if (this.selectedLang === language && !options.force) {
      await this.closeLanguageDropdown();
      return;
    }
    
    // ขั้นตอนที่ 1: อัพเดต state ก่อน
    this.lastSelectedLang = this.selectedLang;
    this.selectedLang = language;
    
    // ขั้นตอนที่ 2: สร้าง URL ใหม่และอัพเดต History (สำคัญที่สุด!)
    const newUrl = this._buildLanguageUrl(language);
    const newVersion = this._incrementVersion();
    
    const state = this._getCurrentState();
    
    // ใช้ pushState เมื่อเปลี่ยนภาษาอย่างชัดเจน (ให้สามารถย้อนกลับได้)
    try {
      history.pushState(state, '', newUrl.toString());
    } catch (e) {
      history.replaceState(state, '', newUrl.toString());
    }
    
    // ขั้นตอนที่ 3: Broadcast ให้ tabs อื่น
    this._broadcastState('lang_change');
    
    // ขั้นตอนที่ 4: อัพเดต content
    await this._applyLanguageContent(language);
    
    // ขั้นตอนที่ 5: อัพเดต UI
    this.showButtonTextForLang(language);
    await this.closeLanguageDropdown();
    
    // ขั้นตอนที่ 6: บันทึก snapshot
    await saveStateSnapshot(state);
  }

  // ใหม่: Internal method สำหรับ apply การเปลี่ยนภาษา (ไม่เปลี่ยน URL)
  async _applyLanguageChange(language, options = {}) {
    if (this.isUpdatingLanguage) return;
    
    try {
      this.isUpdatingLanguage = true;
      
      this.lastSelectedLang = this.selectedLang;
      this.selectedLang = language;
      
      if (!options.fromBroadcast) {
        // ถ้าไม่ได้มาจาก broadcast ให้ increment version
        this._incrementVersion();
      }
      
      await this._applyLanguageContent(language);
      this.showButtonTextForLang(language);
      
      if (options.broadcast !== false) {
        this._broadcastState('lang_change');
      }
    } finally {
      this.isUpdatingLanguage = false;
    }
  }

  // ใหม่: Apply content โดยไม่ยุ่งกับ URL/History
  async _applyLanguageContent(language) {
    document.documentElement.setAttribute("lang", "");
    document.documentElement.setAttribute("lang", language);
    
    // จัดการ google translate meta
    if (language === this.detectBrowserLanguage()) {
      document.documentElement.setAttribute("translate", "no");
      if (!document.querySelector('meta[name="google"][content="notranslate"]')) {
        const meta = document.createElement('meta');
        meta.name = "google";
        meta.content = "notranslate";
        document.head.appendChild(meta);
      }
    } else {
      document.documentElement.removeAttribute("translate");
      const meta = document.querySelector('meta[name="google"][content="notranslate"]');
      if (meta) meta.remove();
    }
    
    // โหลดและ apply translation
    if (language === 'en' && this.getEnSource() !== "json") {
      await this.resetToEnglishContent();
    } else {
      const languageData = await this.loadLanguageData(language);
      if (languageData) {
        await this.parallelStreamingTranslate(languageData);
        this.languageCache[language] = languageData;
      } else {
        await this.resetToEnglishContent();
      }
    }
  }

  // เก่า: รักษาไว้สำหรับ compatibility
  async updatePageLanguage(language, options = { updateHistory: true }) {
    if (options.updateHistory) {
      await this.changeLanguage(language, options);
    } else {
      await this._applyLanguageChange(language, options);
    }
  }

  setupNavigationHandlers() {
    // POPSTATE HANDLER - สำคัญที่สุด!
    window.addEventListener('popstate', async (event) => {
      // ป้องกัน recursive processing
      if (this._processingPopstate) return;
      this._processingPopstate = true;
      
      try {
        if (this.isLanguageDropdownOpen) {
          await this.closeLanguageDropdown();
        }
        
        const state = event.state;
        const currentUrl = new URL(window.location.href);
        const langFromPath = this._langFromPath(currentUrl.pathname);
        
        let targetLang = null;
        let targetVersion = null;
        
        if (state && state.language) {
          // กรณีมี state (กด back/forward ปกติ)
          targetLang = state.language;
          targetVersion = state.version;
        } else if (langFromPath) {
          // กรณีไม่มี state แต่มี path prefix (external link หรือ refresh)
          targetLang = langFromPath;
          targetVersion = this._readStoredState().version;
        } else {
          // กรณีไม่มี state และไม่มี prefix = ภาษาอังกฤษ
          targetLang = 'en';
          targetVersion = this._readStoredState().version;
        }
        
        // ตรวจสอบว่าต้องเปลี่ยนจริงหรือไม่
        if (targetLang !== this.selectedLang || (targetVersion && targetVersion !== this._stateVersion)) {
          console.log(`[LanguageManager] Popstate: ${this.selectedLang} -> ${targetLang} (v${targetVersion})`);
          
          // อัพเดต version ก่อน
          if (targetVersion) this._stateVersion = targetVersion;
          
          // Apply การเปลี่ยนภาษาโดยไม่เปลี่ยน URL (เพราะ URL เปลี่ยนไปแล้วจาก popstate)
          await this._applyLanguageChange(targetLang, { 
            updateHistory: false, 
            broadcast: false 
          });
        }
      } catch (error) {
        console.error('[LanguageManager] Popstate error:', error);
      } finally {
        // ปลด lock หลังจากเวลาผ่านไปเล็กน้อย เพื่อให้ browser จบการทำงาน
        setTimeout(() => {
          this._processingPopstate = false;
        }, 50);
      }
    });

    // STORAGE EVENT - สำหรับ cross-tab sync
    window.addEventListener('storage', (e) => {
      if (e.key === 'lm_selected_lang' || e.key === 'lm_state_version') {
        const stored = this._readStoredState();
        
        // ตรวจสอบว่าเป็นการเปลี่ยนแปลงจริงและใหม่กว่า
        if (stored.lang !== this.selectedLang && stored.version > this._stateVersion) {
          this._stateVersion = stored.version;
          this._applyLanguageChange(stored.lang, { 
            updateHistory: false, 
            fromBroadcast: true 
          });
        }
      }
    });

    // VISIBILITY CHANGE - เมื่อกลับมาที่ tab
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        const stored = this._readStoredState();
        
        // ตรวจสอบว่ามีการเปลี่ยนแปลงจาก tab อื่นหรือไม่
        if (stored.version > this._stateVersion || stored.lang !== this.selectedLang) {
          this._stateVersion = stored.version;
          this._applyLanguageChange(stored.lang, { 
            updateHistory: false, 
            fromBroadcast: true 
          });
        }
      }
    });

    // BEFOREUNLOAD - บันทึก state ก่อนออก
    window.addEventListener('beforeunload', () => {
      try {
        const state = this._getCurrentState();
        history.replaceState(state, '', window.location.href);
      } catch (e) {}
    });
  }

  async parallelStreamingTranslate(languageData, elements) {
    const elList = elements || Array.from(document.querySelectorAll('[data-translate]'));
    if (!elList.length) return;
    
    const chunkSize = Math.max(8, Math.ceil(elList.length / this.maxWorker));
    const batches = [];
    const nodeMeta = [];
    
    for (let i = 0; i < elList.length; i += chunkSize) {
      const batch = elList.slice(i, i + chunkSize);
      batches.push(batch);
      nodeMeta.push(batch.map(el => ({
        key: el.getAttribute('data-translate')
      })));
    }
    
    const jobs = nodeMeta.map((meta, i) =>
      this.workerPool.execute({ nodes: meta, langData: languageData, batchIdx: i })
    );
    
    const results = await Promise.all(jobs);
    
    for (let j = 0; j < results.length; ++j) {
      const batch = batches[j], resArr = results[j].result;
      for (let k = 0; k < resArr.length; ++k) {
        const el = batch[resArr[k].idx];
        if (!el) continue;
        const parts = resArr[k].parts;
        this._replaceDOMWithMarkerReplace(el, parts);
      }
    }
  }

  _replaceDOMWithMarkerReplace(el, parts) {
    // [เก็บโค้ดเดิมไว้ - ทำงานได้ดีแล้ว]
    const normalized = [];
    let buffer = '';
    let bufferHasHtml = false;
    const pushBuffer = () => {
      if (!buffer) return;
      if (bufferHasHtml) normalized.push({ type: 'html', html: buffer });
      else normalized.push({ type: 'text', text: buffer });
      buffer = '';
      bufferHasHtml = false;
    };
    
    for (let i = 0; i < parts.length; i++) {
      const p = parts[i];
      if (p.type === 'text' || p.type === 'html') {
        if (!buffer) {
          buffer = (p.type === 'text') ? (p.text || '') : (p.html || '');
          bufferHasHtml = (p.type === 'html') || /<[^>]+>/.test(buffer);
        } else {
          buffer += (p.type === 'text') ? (p.text || '') : (p.html || '');
          if (p.type === 'html' || /<[^>]+>/.test(buffer)) bufferHasHtml = true;
        }
      } else {
        pushBuffer();
        normalized.push(p);
      }
    }
    pushBuffer();

    const newNodes = [];
    const domParser = new DOMParser();
    let containsExplicitSvgOrLsvg = false;
    
    normalized.forEach(p => {
      if (p.type === 'text') {
        newNodes.push(document.createTextNode(p.text));
      } else if (p.type === 'html') {
        const htmlStr = (p.html || '').trim();
        if (!htmlStr) return;
        if (/\<svg[\s>]/i.test(htmlStr)) {
          try {
            const svgDoc = domParser.parseFromString(htmlStr, 'image/svg+xml');
            const svgRoot = svgDoc.documentElement && svgDoc.documentElement.nodeName !== 'parsererror' ? svgDoc.documentElement : null;
            if (svgRoot) {
              newNodes.push(document.importNode(svgRoot, true));
              containsExplicitSvgOrLsvg = true;
              return;
            }
          } catch (e) {}
        }
        const template = document.createElement('template');
        template.innerHTML = htmlStr;
        const frag = template.content.cloneNode(true);
        Array.from(frag.childNodes).forEach(n => newNodes.push(n));
      } else if (p.type === 'svg') {
        newNodes.push({ __svgMarker: true, id: p.id || null });
        containsExplicitSvgOrLsvg = true;
      } else if (p.type === 'lsvg') {
        newNodes.push({ __svgMarker: true, lsvg: true, id: p.id || null });
        containsExplicitSvgOrLsvg = true;
      } else if (p.type === 'slot') {
        newNodes.push({ __slotMarker: true, name: p.name || null });
      } else {
        newNodes.push(this._createMarkerNode(p));
      }
    });

    const existingSvgsAll = Array.from(el.querySelectorAll ? el.querySelectorAll('svg') : []).slice();
    if (!containsExplicitSvgOrLsvg && existingSvgsAll.length > 0) {
      newNodes.unshift({ __svgMarker: true, lsvg: true, id: null, __predicted: true });
    }

    const existing = Array.from(el.childNodes);
    const existingSvgs = existingSvgsAll.slice();
    const existingSlotsAll = Array.from(el.querySelectorAll ? el.querySelectorAll('[data-translate-slot],[data-slot]') : []).slice();
    const usedSvgs = new Set();
    const usedSlots = new Set();
    const existingAnchorsAll = Array.from(el.querySelectorAll ? el.querySelectorAll('a') : []).slice();
    const usedAnchors = new Set();

    const resolveSvgMarkerGlobal = (id) => {
      if (id) {
        for (let s of existingSvgs) {
          if (usedSvgs.has(s)) continue;
          if ((s.getAttribute && s.getAttribute('id') === id) || (s.getAttribute && s.getAttribute('data-svg-id') === id) || (s.dataset && s.dataset.svgId === id)) {
            usedSvgs.add(s);
            return s;
          }
        }
      }
      const available = existingSvgs.filter(s => !usedSvgs.has(s));
      if (available.length >= 1) {
        usedSvgs.add(available[0]);
        return available[0];
      }
      return null;
    };

    const resolveSlotMarkerGlobal = (name) => {
      if (name) {
        for (let s of existingSlotsAll) {
          if (usedSlots.has(s)) continue;
          if ((s.getAttribute && s.getAttribute('data-translate-slot') === name) ||
              (s.getAttribute && s.getAttribute('data-slot') === name) ||
              (s.dataset && (s.dataset.translateSlot === name || s.dataset.slot === name))) {
            usedSlots.add(s);
            return s;
          }
        }
      }
      const available = existingSlotsAll.filter(s => !usedSlots.has(s));
      if (!name && available.length === 1) {
        usedSlots.add(available[0]);
        return available[0];
      }
      return null;
    };

    const resolveAnchorMarkerGlobal = (newNode) => {
      const id = (newNode && newNode.getAttribute && newNode.getAttribute('id')) || (newNode && newNode.dataset && newNode.dataset.id) || null;
      if (id) {
        for (let a of existingAnchorsAll) {
          if (usedAnchors.has(a)) continue;
          if ((a.getAttribute && a.getAttribute('id') === id) || (a.getAttribute && a.getAttribute('data-anchor-id') === id) || (a.dataset && (a.dataset.anchorId === id || a.dataset.id === id))) {
            usedAnchors.add(a);
            return a;
          }
        }
      }
      const available = existingAnchorsAll.filter(a => !usedAnchors.has(a));
      if (available.length >= 1) {
        usedAnchors.add(available[0]);
        return available[0];
      }
      return null;
    };

    let readIndex = 0;
    for (let i = 0; i < newNodes.length; i++) {
      const newNode = newNodes[i];
      let currentOld = existing[readIndex];

      if (newNode && newNode.__slotMarker) {
        const slotEl = resolveSlotMarkerGlobal(newNode.name);
        if (slotEl) {
          if (currentOld !== slotEl) {
            try { el.insertBefore(slotEl, currentOld || null); } catch (e) {}
            existing.splice(existing.indexOf(slotEl), 1);
            existing.splice(readIndex, 0, slotEl);
            currentOld = existing[readIndex];
          }
          readIndex++;
          continue;
        } else {
          const span = document.createElement('span');
          if (newNode.name) {
            try { span.setAttribute('data-translate-slot', newNode.name); } catch(e){}
          } else {
            try { span.setAttribute('data-translate-slot', 'slot'); } catch(e){}
          }
          if (currentOld) el.insertBefore(span, currentOld);
          else el.appendChild(span);
          existing.splice(readIndex, 0, span);
          readIndex++;
          continue;
        }
      }

      if (newNode && newNode.__svgMarker) {
        const svgRef = resolveSvgMarkerGlobal(newNode.id);
        if (svgRef) {
          if (newNode.__predicted) {
            try {
              if (el.firstChild !== svgRef) {
                el.insertBefore(svgRef, el.firstChild);
              }
              const idxOld = existing.indexOf(svgRef);
              if (idxOld !== -1) {
                existing.splice(idxOld, 1);
                existing.splice(0, 0, svgRef);
              }
              if (readIndex === 0) {
                readIndex = 1;
              }
            } catch (e) {}
            continue;
          }

          if (currentOld !== svgRef) {
            try {
              el.insertBefore(svgRef, currentOld || null);
            } catch (e) {}
            const prevIdx = existing.indexOf(svgRef);
            if (prevIdx !== -1) existing.splice(prevIdx, 1);
            existing.splice(readIndex, 0, svgRef);
            currentOld = existing[readIndex];
          }
          readIndex++;
          continue;
        } else {
          const ns = "http://www.w3.org/2000/svg";
          const createdSvg = document.createElementNS(ns, 'svg');
          if (newNode.id) {
            try { createdSvg.setAttribute('id', newNode.id); createdSvg.setAttribute('data-svg-id', newNode.id); } catch(e){}
          }
          if (newNode.__predicted) {
            if (el.firstChild) el.insertBefore(createdSvg, el.firstChild);
            else el.appendChild(createdSvg);
            existing.splice(0, 0, createdSvg);
            if (readIndex === 0) readIndex = 1;
            continue;
          } else {
            if (currentOld) el.insertBefore(createdSvg, currentOld);
            else el.appendChild(createdSvg);
            existing.splice(readIndex, 0, createdSvg);
            readIndex++;
            continue;
          }
        }
      }

      if (newNode && newNode.nodeType === 1 && newNode.tagName && newNode.tagName.toLowerCase() === 'a') {
        const anchorRef = resolveAnchorMarkerGlobal(newNode);
        if (anchorRef) {
          if (currentOld !== anchorRef) {
            try {
              el.insertBefore(anchorRef, currentOld || null);
            } catch (e) {}
            const prevIdx = existing.indexOf(anchorRef);
            if (prevIdx !== -1) existing.splice(prevIdx, 1);
            existing.splice(readIndex, 0, anchorRef);
            currentOld = existing[readIndex];
          }
          try {
            if (newNode.textContent != null && newNode.textContent !== '') {
              if (anchorRef.textContent !== newNode.textContent) anchorRef.textContent = newNode.textContent;
            }
            const newAttrs = Array.from(newNode.attributes || []);
            newAttrs.forEach(a => {
              try { anchorRef.setAttribute(a.name, a.value); } catch(e){}
            });
          } catch (e) {}
          readIndex++;
          continue;
        } else {
          if (currentOld) el.insertBefore(document.importNode(newNode, true), currentOld);
          else el.appendChild(document.importNode(newNode, true));
          existing.splice(readIndex, 0, el.childNodes[readIndex]);
          readIndex++;
          continue;
        }
      }

      if (currentOld) {
        if (currentOld.nodeType === Node.TEXT_NODE && newNode.nodeType === Node.TEXT_NODE) {
          if (currentOld.textContent !== newNode.textContent) currentOld.textContent = newNode.textContent;
          readIndex++;
          continue;
        }

        if (currentOld.nodeType === 1 && newNode.nodeType === 1) {
          try {
            if (currentOld.tagName === newNode.tagName) {
              while (currentOld.firstChild) currentOld.removeChild(currentOld.firstChild);
              Array.from(newNode.childNodes).forEach(c => currentOld.appendChild(document.importNode(c, true)));
              const newAttrs = Array.from(newNode.attributes || []);
              const oldAttrs = Array.from(currentOld.attributes || []);
              newAttrs.forEach(a => {
                try { currentOld.setAttribute(a.name, a.value); } catch(e){}
              });
              oldAttrs.forEach(a => {
                if (!newNode.hasAttribute(a.name)) {
                  try { currentOld.removeAttribute(a.name); } catch(e){}
                }
              });
              readIndex++;
              continue;
            }
          } catch (e) {}
        }

        if (currentOld.nodeType === 1 && currentOld.tagName && currentOld.tagName.toLowerCase() === 'svg') {
          readIndex++;
          i--;
          continue;
        }

        if (currentOld.nodeType === 1 && (currentOld.hasAttribute && (currentOld.hasAttribute('data-translate-slot') || currentOld.hasAttribute('data-slot')))) {
          readIndex++;
          i--;
          continue;
        }

        try {
          el.replaceChild(document.importNode(newNode, true), currentOld);
          existing[readIndex] = el.childNodes[readIndex];
          readIndex++;
          continue;
        } catch (e) {
          try {
            el.insertBefore(document.importNode(newNode, true), currentOld);
            el.removeChild(currentOld);
            existing[readIndex] = el.childNodes[readIndex];
            readIndex++;
            continue;
          } catch (e2) {
            readIndex++;
            continue;
          }
        }
      } else {
        try {
          el.appendChild(document.importNode(newNode, true));
          existing.push(el.lastChild);
        } catch (e) {
          try { el.appendChild(newNode.cloneNode(true)); existing.push(el.lastChild); } catch (e2) {}
        }
        readIndex++;
        continue;
      }
    }

    for (let j = el.childNodes.length - 1; j >= readIndex; j--) {
      const node = el.childNodes[j];
      if (!node) continue;
      if (node.nodeType === 1 && node.tagName && node.tagName.toLowerCase() === 'svg') {
        continue;
      }
      if (node.nodeType === 1 && (node.hasAttribute && (node.hasAttribute('data-translate-slot') || node.hasAttribute('data-slot')))) {
        continue;
      }
      try { el.removeChild(node); } catch(e){}
    }
  }

  _createMarkerNode(marker) {
    if (marker.type === 'text') {
      return document.createTextNode(marker.text);
    } else if (marker.type === 'a') {
      const a = document.createElement('a');
      if (marker.translate) a.textContent = marker.text;
      return a;
    } else if (marker.type === 'br') {
      return document.createElement('br');
    } else if (marker.type === 'strong') {
      const s = document.createElement('strong');
      s.textContent = marker.text;
      return s;
    } else if (marker.type === 'html') {
      const template = document.createElement('template');
      template.innerHTML = marker.html || '';
      return template.content.cloneNode(true);
    }
    return document.createTextNode('');
  }

  // UI Methods (เก็บไว้เหมือนเดิม)
  initializeCustomLanguageSelector() {
    const container = document.getElementById('language-selector-container');
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton) return;
    
    this.prepareAllButtonTexts();
    this.showButtonTextForLang(this.selectedLang || 'en');
    
    if (this.languageOverlay && this.languageOverlay.parentElement) {
      this.languageOverlay.parentElement.removeChild(this.languageOverlay);
      this.languageOverlay = null;
    }
    if (this.languageDropdown && this.languageDropdown.parentElement) {
      this.languageDropdown.parentElement.removeChild(this.languageDropdown);
      this.languageDropdown = null;
    }
    
    this.languageOverlay = document.createElement('div');
    this.languageOverlay.id = 'language-overlay';
    document.body.appendChild(this.languageOverlay);
    
    this.languageDropdown = document.createElement('div');
    this.languageDropdown.id = 'language-dropdown';
    this.languageDropdown.innerHTML = '';
    this.populateLanguageDropdown();
    document.body.appendChild(this.languageDropdown);
    
    this.setupEventListeners();
    this.setupDropdownScrollLock();
  }

  populateLanguageDropdown() {
    const fragment = document.createDocumentFragment();
    Object.entries(this.languagesConfig).forEach(([lang, config]) => {
      const option = document.createElement('div');
      option.className = 'language-option';
      option.textContent = config.label;
      option.dataset.language = lang;
      fragment.appendChild(option);
    });
    this.languageDropdown.innerHTML = '';
    this.languageDropdown.appendChild(fragment);
  }

  setupEventListeners() {
    if (!this.languageButton) return;
    this.languageButton.onclick = () => this.toggleLanguageDropdown();
    this.languageOverlay.onclick = () => this.closeLanguageDropdown();
    this.languageDropdown.onclick = (e) => {
      const option = e.target.closest('.language-option');
      if (option) {
        const lang = option.dataset.language;
        if (lang) this.selectLanguage(lang);
      }
    };
  }

  setupDropdownScrollLock() {
    if (!this.languageDropdown) return;
    
    this._dropdownWheelListener = (e) => {
      const el = this.languageDropdown;
      const delta = e.deltaY;
      const atTop = el.scrollTop === 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if ((atTop && delta < 0) || (atBottom && delta > 0)) e.preventDefault();
      e.stopPropagation();
    };
    
    this.languageDropdown.addEventListener('wheel', this._dropdownWheelListener, { passive: false });
    
    let lastY = 0;
    this._dropdownTouchStartListener = (e) => {
      if (e.touches.length === 1) lastY = e.touches[0].clientY;
    };
    
    this._dropdownTouchMoveListener = (e) => {
      if (e.touches.length !== 1) return;
      const el = this.languageDropdown;
      const currentY = e.touches[0].clientY;
      const delta = lastY - currentY;
      lastY = currentY;
      const atTop = el.scrollTop === 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if ((atTop && delta < 0) || (atBottom && delta > 0)) e.preventDefault();
      e.stopPropagation();
    };
    
    this.languageDropdown.addEventListener('touchstart', this._dropdownTouchStartListener);
    this.languageDropdown.addEventListener('touchmove', this._dropdownTouchMoveListener, { passive: false });
  }

  toggleLanguageDropdown() {
    this.isLanguageDropdownOpen ? this.closeLanguageDropdown() : this.openLanguageDropdown();
  }

  async openLanguageDropdown() {
    if (this.isLanguageDropdownOpen) return;
    this.scrollPosition = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
    this.isLanguageDropdownOpen = true;
    this.languageOverlay.style.display = 'block';
    this.languageDropdown.style.display = 'block';
    document.body.style.position = 'fixed';
    document.body.style.left = '0';
    document.body.style.right = '0';
    document.body.style.overflowY = 'scroll';
    document.body.style.top = `-${this.scrollPosition}px`;
    document.body.classList.add('scroll-lock');
    
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        this.languageOverlay.classList.add('fade-in');
        this.languageDropdown.classList.add('fade-in');
        setTimeout(resolve, this.FADE_DURATION);
      });
    });
  }

  async closeLanguageDropdown() {
    if (!this.isLanguageDropdownOpen) return;
    const dropdownResetDelay = 80;
    
    return new Promise(resolve => {
      this.isLanguageDropdownOpen = false;
      this.languageOverlay.classList.remove('fade-in');
      this.languageDropdown.classList.remove('fade-in');
      this.languageOverlay.classList.add('fade-out');
      this.languageDropdown.classList.add('fade-out');
      document.body.classList.remove('scroll-lock');
      document.body.style.position = '';
      document.body.style.left = '';
      document.body.style.right = '';
      document.body.style.overflowY = '';
      document.body.style.top = '';
      window.scrollTo(0, this.scrollPosition);
      
      setTimeout(() => {
        if (this.languageDropdown) {
          this.languageDropdown.scrollTop = 0;
          this.languageDropdown.scrollLeft = 0;
        }
      }, this.FADE_DURATION - dropdownResetDelay);
      
      setTimeout(() => {
        this.languageOverlay.style.display = 'none';
        this.languageDropdown.style.display = 'none';
        this.languageOverlay.classList.remove('fade-out');
        this.languageDropdown.classList.remove('fade-out');
        resolve();
      }, this.FADE_DURATION);
    });
  }

  async selectLanguage(language) {
    await this.changeLanguage(language);
  }

  storeOriginalContent() {
    document.querySelectorAll('[data-translate]').forEach(el => {
      if (!el.hasAttribute('data-original-text')) {
        el.setAttribute('data-original-text', el.textContent.trim());
      }
      if (!el.hasAttribute('data-original-style')) {
        el.setAttribute('data-original-style', el.style.cssText);
      }
    });
  }

  async resetToEnglishContent() {
    const elements = document.querySelectorAll('[data-translate]');
    const resetPromises = Array.from(elements).map(el => new Promise(resolve => {
      requestAnimationFrame(() => {
        const originalText = el.getAttribute('data-original-text');
        const originalStyle = el.getAttribute('data-original-style');
        
        if (originalText) {
          const workerCode = `
            function splitMarkersAndHtml(str) {
              const htmlSplit = str.split(/(<\\/?.+?>)/g);
              const parts = [];
              const markerRegex = /(@lsvg(?::([^@]+))?@)|(@svg(?::([^@]+))?@)|(@slot:([^@]+)@)|(@a(.*?)@)|(@br)|(@strong(.*?)@)/g;
              for (let segment of htmlSplit) {
                if (!segment) continue;
                if (/^<\\/?.+?>$/.test(segment)) {
                  parts.push({ type: 'html', html: segment });
                } else {
                  let lastIndex = 0;
                  let m;
                  while ((m = markerRegex.exec(segment)) !== null) {
                    if (m.index > lastIndex) {
                      parts.push({ type: 'text', text: segment.slice(lastIndex, m.index)});
                    }
                    if (m[1]) {
                      const id = m[2] || null;
                      parts.push({ type: 'lsvg', id });
                    } else if (m[3]) {
                      const id = m[4] || null;
                      parts.push({ type: 'svg', id });
                    } else if (m[5]) {
                      const name = m[6] || null;
                      parts.push({ type: 'slot', name });
                    } else if (m[7]) {
                      const inner = m[8] || '';
                      parts.push({ type: 'a', translate: inner !== "", text: inner });
                    } else if (m[9]) {
                      parts.push({ type: 'br' });
                    } else if (m[10]) {
                      const s = m[11] || '';
                      parts.push({ type: 'strong', text: s });
                    }
                    lastIndex = markerRegex.lastIndex;
                  }
                  if (lastIndex < segment.length) {
                    parts.push({ type: 'text', text: segment.slice(lastIndex) });
                  }
                }
              }
              return parts;
            }
            self.onmessage = function(e) {
              self.postMessage(splitMarkersAndHtml(e.data));
            }
          `;
          let w = new Worker(URL.createObjectURL(new Blob([workerCode], {type: 'application/javascript'})));
          w.onmessage = e => {
            this._replaceDOMWithMarkerReplace(el, e.data);
            w.terminate();
            resolve();
          };
          w.postMessage(originalText);
        } else {
          resolve();
        }
        
        if (originalStyle) {
          el.style.cssText = originalStyle;
        }
      });
    }));
    
    await Promise.all(resetPromises);
  }

  showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'language-error';
    errorDiv.textContent = message;
    Object.assign(errorDiv.style, {
      position: 'fixed',
      top: '20px',
      right: '20px',
      backgroundColor: '#ff4444',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '4px',
      zIndex: '9999',
      opacity: '0',
      transition: 'opacity 0.3s ease'
    });
    document.body.appendChild(errorDiv);
    requestAnimationFrame(() => {
      errorDiv.style.opacity = '1';
      setTimeout(() => {
        errorDiv.style.opacity = '0';
        setTimeout(() => errorDiv.remove(), this.FADE_DURATION);
      }, 3000);
    });
  }

  observeMutations() {
    if (this.mutationObserver) { this.mutationObserver.disconnect(); }
    
    this.mutationObserver = new MutationObserver((mutations) => {
      if (this.mutationThrottleTimeout) return;
      
      this.mutationThrottleTimeout = setTimeout(() => {
        let needsUpdate = false, added = [];
        mutations.forEach(mutation => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const translatableElements = node.querySelectorAll('[data-translate]');
                if (translatableElements.length > 0) {
                  needsUpdate = true;
                  added.push(...translatableElements);
                  translatableElements.forEach(el => {
                    if (!el.hasAttribute('data-original-text')) {
                      el.setAttribute('data-original-text', el.textContent.trim());
                    }
                  });
                }
              }
            });
          }
        });
        
        if (needsUpdate && (this.selectedLang !== 'en' || this.getEnSource() === "json")) {
          this.parallelStreamingTranslate(this.languageCache[this.selectedLang], added);
        }
        
        this.mutationThrottleTimeout = null;
      }, 1);
    });
    
    this.mutationObserver.observe(document.body, { childList: true, subtree: true });
  }

  destroy() {
    if (this.languageOverlay) this.languageOverlay.remove();
    if (this.languageDropdown) this.languageDropdown.remove();
    if (this.mutationObserver) this.mutationObserver.disconnect();
    this.languageCache = {};
    this.isInitialized = false;
    this.isLanguageDropdownOpen = false;
    this.isUpdatingLanguage = false;
    this.isNavigating = false;
    if (this.workerPool) this.workerPool.destroy();
    if (this._bc) try { this._bc.close(); } catch (e) {}
  }
}

const languageManager = new LanguageManager();
window.languageManager = languageManager;
if (typeof module !== 'undefined' && module.exports) module.exports = languageManager;
