/**
 * LanguageManager Ultra-Enterprise: State-Driven Architecture
 * - แก้ไขปัญหา Back/Forward ไม่ตรงภาษา
 * - เปลี่ยนลำดับ: URL → Content (ไม่ refresh)
 * - History state เป็น source of truth
 * - รองรับ local development โดยไม่ redirect
 */

const DB_NAME = "LanguageCacheDB";
const DB_STORE = "langs";
const DB_VERSION = 2;

class LanguageManager {
  constructor() {
    this.config = null;
    this.cache = {};
    this.currentLang = 'en';
    this.previousLang = null;
    this.isUpdating = false;
    this.isDropdownOpen = false;
    this.isLocalDev = this._detectLocalDev();
    this.workerPool = this._createWorkerPool();
    
    this._init();
  }

  // ============ Initialization ============
  
  async _init() {
    await this._loadConfig();
    this._setupInitialLanguage();
    this._setupEventListeners();
    this._setupMutationObserver();
    this._initUI();
  }

  _detectLocalDev() {
    try {
      const host = location.hostname || '';
      if (!host || host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return true;
      if (host.endsWith('.local')) return true;
      if (['3000','5173','7700','8080','3001','4173'].includes(String(location.port))) return true;
      return false;
    } catch (e) { return false; }
  }

  _createWorkerPool() {
    const workerCode = `
      self.onmessage = function(e) {
        const { text, key } = e.data;
        const parts = [];
        const regex = /(@(svg|lsvg|a|strong|br|slot)(?::([^@]+))?@)|(<[^>]+>)/g;
        let lastIndex = 0;
        let m;
        
        while ((m = regex.exec(text)) !== null) {
          if (m.index > lastIndex) {
            parts.push({ type: 'text', content: text.slice(lastIndex, m.index) });
          }
          if (m[4]) {
            parts.push({ type: 'html', content: m[4] });
          } else {
            parts.push({ type: m[2], id: m[3] || null });
          }
          lastIndex = regex.lastIndex;
        }
        
        if (lastIndex < text.length) {
          parts.push({ type: 'text', content: text.slice(lastIndex) });
        }
        
        self.postMessage({ key, parts });
      };
    `;
    
    const workers = [];
    const maxWorkers = navigator.hardwareConcurrency ? Math.min(4, navigator.hardwareConcurrency) : 2;
    
    for (let i = 0; i < maxWorkers; i++) {
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      workers.push(new Worker(URL.createObjectURL(blob)));
    }
    
    return {
      execute: (data) => new Promise((resolve, reject) => {
        const worker = workers[Math.floor(Math.random() * workers.length)];
        const handler = (e) => {
          worker.removeEventListener('message', handler);
          resolve(e.data);
        };
        worker.addEventListener('message', handler);
        worker.postMessage(data);
      }),
      terminate: () => workers.forEach(w => w.terminate())
    };
  }

  // ============ IndexedDB Cache ============
  
  async _openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onerror = () => reject(req.error);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) {
          db.createObjectStore(DB_STORE, { keyPath: 'lang' });
        }
      };
      req.onsuccess = () => resolve(req.result);
    });
  }

  async _getCached(lang) {
    try {
      const db = await this._openDB();
      return new Promise(resolve => {
        const tx = db.transaction(DB_STORE, 'readonly');
        const store = tx.objectStore(DB_STORE);
        const req = store.get(lang);
        req.onsuccess = () => resolve(req.result?.data || null);
        req.onerror = () => resolve(null);
      });
    } catch (e) { return null; }
  }

  async _setCached(lang, data) {
    try {
      const db = await this._openDB();
      return new Promise(resolve => {
        const tx = db.transaction(DB_STORE, 'readwrite');
        const store = tx.objectStore(DB_STORE);
        store.put({ lang, data, ts: Date.now() });
        tx.oncomplete = resolve;
        tx.onerror = resolve;
      });
    } catch (e) {}
  }

  // ============ Configuration ============
  
  async _loadConfig() {
    const cacheKey = '__lang_cfg';
    const url = '/assets/lang/options/db.min.json';
    
    try {
      // Try cache first
      const stored = localStorage.getItem(cacheKey);
      let needFetch = true;
      
      if (stored && !this.isLocalDev) {
        try {
          const head = await fetch(url, { method: 'HEAD' });
          const etag = head.headers.get('ETag');
          const cachedEtag = localStorage.getItem('__lang_cfg_etag');
          if (etag && etag === cachedEtag) needFetch = false;
        } catch (e) {}
      }
      
      if (needFetch) {
        const res = await fetch(url, { cache: 'no-store' });
        const data = await res.json();
        this.config = data;
        localStorage.setItem(cacheKey, JSON.stringify(data));
        localStorage.setItem('__lang_cfg_etag', res.headers.get('ETag') || '');
      } else {
        this.config = JSON.parse(stored);
      }
    } catch (e) {
      const fallback = localStorage.getItem(cacheKey);
      this.config = fallback ? JSON.parse(fallback) : { 
        en: { label: 'English', buttonText: 'EN' },
        th: { label: 'ไทย', buttonText: 'TH' }
      };
    }
  }

  // ============ Language Detection ============
  
  _getLangFromPath(path = location.pathname) {
    const match = path.match(/^\/([a-z]{2})(?:\/|$)/i);
    if (!match) return null;
    const lang = match[1].toLowerCase();
    return this.config?.[lang] ? lang : null;
  }

  _detectBrowserLanguage() {
    const langs = navigator.languages || [navigator.language || 'en'];
    for (const lang of langs) {
      const code = lang.split('-')[0].toLowerCase();
      if (this.config?.[code]) return code;
    }
    return 'en';
  }

  _setupInitialLanguage() {
    // Priority: URL path > Query > localStorage > Browser > Default
    const pathLang = this._getLangFromPath();
    const queryLang = new URLSearchParams(location.search).get('lang');
    const storedLang = localStorage.getItem('selectedLang');
    const browserLang = this._detectBrowserLanguage();
    
    const detected = pathLang || queryLang || storedLang || browserLang || 'en';
    const validLang = this.config?.[detected] ? detected : 'en';
    
    this.currentLang = validLang;
    this.previousLang = validLang;
    
    // ถ้าไม่มี prefix ใน production → redirect ไป prefixed URL
    if (!this.isLocalDev && !pathLang && validLang !== 'en') {
      this._redirectToPrefixed(validLang);
      return;
    }
    
    // บันทึก state เริ่มต้น
    if (!history.state?.language) {
      this._updateHistoryState(validLang, false);
    }
    
    // โหลดภาษาเริ่มต้น
    if (validLang !== 'en') {
      this._applyLanguage(validLang, false);
    }
  }

  _getPrefixedPath(lang, currentPath = location.pathname) {
    // ลบ prefix เก่า
    const cleanPath = currentPath.replace(/^\/[a-z]{2}\b/, '') || '/';
    if (lang === 'en') return cleanPath;
    return `/${lang}${cleanPath === '/' ? '' : cleanPath}`;
  }

  _redirectToPrefixed(lang) {
    const newPath = this._getPrefixedPath(lang);
    const newUrl = newPath + location.search + location.hash;
    // ใช้ replace ไม่สร้าง history entry ให้ redirect นี้
    location.replace(newUrl);
  }

  // ============ Core: URL & History Management ============
  
  /**
   * จุดสำคัญ: อัพเดต URL ก่อนเสมอ แล้วค่อยอัพเดต content
   */
  _updateHistoryState(lang, usePushState = true) {
    const newPath = this._getPrefixedPath(lang);
    const newUrl = newPath + location.search + location.hash;
    
    const state = {
      language: lang,
      previousLanguage: this.previousLang,
      timestamp: Date.now(),
      path: newPath
    };
    
    try {
      if (usePushState) {
        history.pushState(state, '', newUrl);
      } else {
        history.replaceState(state, '', newUrl);
      }
    } catch (e) {
      // Fallback ถ้า pushState ไม่ได้
      if (usePushState) location.href = newUrl;
    }
  }

  /**
   * Public API: เปลี่ยนภาษา
   * ลำดับ: URL (pushState) → localStorage → Content → Broadcast
   */
  async selectLanguage(newLang) {
    if (newLang === this.currentLang || this.isUpdating) return;
    
    this.isUpdating = true;
    
    try {
      // 1. อัพเดต internal state
      this.previousLang = this.currentLang;
      this.currentLang = newLang;
      
      // 2. เปลี่ยน URL ทันที (สำคัญ: pushState ก่อน)
      this._updateHistoryState(newLang, true);
      
      // 3. บันทึก localStorage
      localStorage.setItem('selectedLang', newLang);
      
      // 4. อัพเดต content (ไม่ reload)
      await this._applyLanguage(newLang, true);
      
      // 5. แจ้งแท็บอื่น
      this._broadcastChange(newLang);
      
      // 6. อัพเดต UI
      this._updateUI(newLang);
      
    } finally {
      this.isUpdating = false;
    }
  }

  // ============ Content Translation ============
  
  async _applyLanguage(lang, animate = true) {
    if (animate) {
      document.body.style.transition = 'opacity 0.2s ease';
      document.body.style.opacity = '0.6';
    }
    
    try {
      if (lang === 'en' && this._getEnSource() === 'html') {
        await this._resetToOriginal();
      } else {
        const data = await this._loadLanguageData(lang);
        if (data) {
          await this._translateAll(data);
        } else {
          await this._resetToOriginal();
        }
      }
      
      document.documentElement.lang = lang;
      document.documentElement.setAttribute('lang', lang);
      
    } catch (e) {
      console.error('Language apply failed:', e);
      await this._resetToOriginal();
    }
    
    if (animate) {
      requestAnimationFrame(() => {
        document.body.style.opacity = '1';
        setTimeout(() => {
          document.body.style.transition = '';
        }, 200);
      });
    }
  }

  _getEnSource() {
    return this.config?.en?.enSource === 'json' ? 'json' : 'html';
  }

  async _loadLanguageData(lang) {
    if (this.cache[lang]) return this.cache[lang];
    
    // Try cache first
    const cached = await this._getCached(lang);
    if (cached) {
      this.cache[lang] = cached;
      return cached;
    }
    
    try {
      const res = await fetch(`/assets/lang/${lang}.min.json`, { cache: 'no-store' });
      const json = await res.json();
      const flat = this._flattenJson(json);
      this.cache[lang] = flat;
      await this._setCached(lang, flat);
      return flat;
    } catch (e) {
      return null;
    }
  }

  _flattenJson(obj, prefix = '', result = {}) {
    for (const [k, v] of Object.entries(obj)) {
      const key = prefix ? `${prefix}.${k}` : k;
      if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
        this._flattenJson(v, key, result);
      } else {
        result[key] = String(v);
      }
    }
    return result;
  }

  async _translateAll(langData) {
    const elements = Array.from(document.querySelectorAll('[data-translate]'));
    if (!elements.length) return;
    
    // Process in batches
    const batchSize = 30;
    for (let i = 0; i < elements.length; i += batchSize) {
      const batch = elements.slice(i, i + batchSize);
      await Promise.all(batch.map(el => this._translateElement(el, langData)));
    }
  }

  async _translateElement(el, langData) {
    const key = el.getAttribute('data-translate');
    const translation = langData[key];
    if (!translation) return;
    
    // Store original if not exists
    if (!el.hasAttribute('data-original')) {
      el.setAttribute('data-original', el.innerHTML);
    }
    
    // Parse with worker
    const { parts } = await this.workerPool.execute({ text: translation, key });
    
    // Render
    this._renderParts(el, parts);
  }

  _renderParts(el, parts) {
    // Collect existing special elements for reuse
    const existingSvgs = Array.from(el.querySelectorAll('svg'));
    const existingSlots = Array.from(el.querySelectorAll('[data-slot], [data-translate-slot]'));
    const existingAnchors = Array.from(el.querySelectorAll('a[href]'));
    
    const usedSvgs = new Set();
    const usedSlots = new Set();
    const usedAnchors = new Set();
    
    // Build new content
    const fragment = document.createDocumentFragment();
    
    for (const part of parts) {
      if (part.type === 'text') {
        const span = document.createElement('span');
        span.innerHTML = part.content;
        while (span.firstChild) {
          fragment.appendChild(span.firstChild);
        }
      }
      else if (part.type === 'html') {
        const span = document.createElement('span');
        span.innerHTML = part.content;
        while (span.firstChild) {
          fragment.appendChild(span.firstChild);
        }
      }
      else if (part.type === 'svg' || part.type === 'lsvg') {
        // Find matching SVG
        let svg = null;
        if (part.id) {
          svg = existingSvgs.find(s => 
            (s.id === part.id || s.dataset.svgId === part.id) && !usedSvgs.has(s)
          );
        }
        if (!svg) {
          svg = existingSvgs.find(s => !usedSvgs.has(s));
        }
        if (svg) {
          usedSvgs.add(svg);
          fragment.appendChild(svg.cloneNode(true));
        }
      }
      else if (part.type === 'slot') {
        let slot = null;
        if (part.id) {
          slot = existingSlots.find(s => 
            (s.dataset.slot === part.id || s.dataset.translateSlot === part.id) && !usedSlots.has(s)
          );
        }
        if (!slot) {
          slot = existingSlots.find(s => !usedSlots.has(s));
        }
        if (slot) {
          usedSlots.add(slot);
          fragment.appendChild(slot);
        }
      }
      else if (part.type === 'a') {
        // Reuse existing anchor if possible
        let anchor = existingAnchors.find(a => !usedAnchors.has(a));
        if (anchor) {
          usedAnchors.add(anchor);
          if (part.content) anchor.textContent = part.content;
          fragment.appendChild(anchor);
        } else {
          const a = document.createElement('a');
          a.href = '#';
          if (part.content) a.textContent = part.content;
          fragment.appendChild(a);
        }
      }
      else if (part.type === 'strong') {
        const s = document.createElement('strong');
        if (part.content) s.textContent = part.content;
        fragment.appendChild(s);
      }
      else if (part.type === 'br') {
        fragment.appendChild(document.createElement('br'));
      }
    }
    
    el.innerHTML = '';
    el.appendChild(fragment);
  }

  async _resetToOriginal() {
    const elements = document.querySelectorAll('[data-translate]');
    elements.forEach(el => {
      const original = el.getAttribute('data-original');
      if (original) el.innerHTML = original;
    });
  }

  // ============ Event Handling (สำคัญมาก) ============
  
  _setupEventListeners() {
    /**
     * POPSTATE - จุดแก้ไขหลัก
     * อ่านจาก event.state ก่อนเสมอ ไม่ใช่จาก URL
     */
    window.addEventListener('popstate', (e) => {
      this._handlePopState(e);
    });
    
    // Storage events (cross-tab sync)
    window.addEventListener('storage', (e) => {
      if (e.key === 'selectedLang') {
        const newLang = e.newValue;
        if (newLang && newLang !== this.currentLang) {
          this.previousLang = this.currentLang;
          this.currentLang = newLang;
          this._applyLanguage(newLang, false);
          this._updateUI(newLang);
        }
      }
    });
    
    // Visibility change (กลับมาจากแท็บอื่น)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        const stored = localStorage.getItem('selectedLang');
        if (stored && stored !== this.currentLang) {
          this.previousLang = this.currentLang;
          this.currentLang = stored;
          this._applyLanguage(stored, false);
          this._updateUI(stored);
        }
      }
    });
    
    // Intercept link clicks to maintain language prefix
    document.addEventListener('click', (e) => {
      const a = e.target.closest('a[href^="/"]');
      if (!a || this.isLocalDev) return;
      
      const href = a.getAttribute('href');
      if (href.startsWith('/assets/') || href.startsWith('/api/') || href.startsWith('/_next/')) return;
      
      // ถ้า link ไม่มี prefix แต่เรากำลังอยู่ในภาษาอื่น → เพิ่ม prefix
      if (this.currentLang !== 'en' && !href.match(/^\/[a-z]{2}\b/i)) {
        e.preventDefault();
        const newHref = `/${this.currentLang}${href === '/' ? '' : href}`;
        history.pushState({
          language: this.currentLang,
          previousLanguage: this.previousLang,
          timestamp: Date.now(),
          path: newHref
        }, '', newHref + location.search + location.hash);
        
        // Load new page content หรือ navigate
        location.href = newHref + location.search + location.hash;
      }
    }, true);
  }

  /**
   * จุดสำคัญ: จัดการ popstate
   * อ่านจาก state ก่อน ไม่ใช่จาก URL
   */
  _handlePopState(e) {
    if (this.isUpdating) return;
    
    const stateLang = e.state?.language;
    const statePath = e.state?.path;
    
    // กรณีมี state (ปกติ) - ใช้ state เป็นหลัก
    if (stateLang && this.config?.[stateLang]) {
      if (stateLang !== this.currentLang) {
        this.previousLang = e.state?.previousLanguage || this.currentLang;
        this.currentLang = stateLang;
        this._applyLanguage(stateLang, false);
        this._updateUI(stateLang);
        
        // Sync localStorage เพื่อให้แท็บอื่นตรงกัน
        localStorage.setItem('selectedLang', stateLang);
      }
      return;
    }
    
    // กรณีไม่มี state (เปิดลิงก์จากภายนอก หรือ direct URL access)
    // ค่อยอ่านจาก URL path
    const pathLang = this._getLangFromPath();
    if (pathLang && pathLang !== this.currentLang) {
      this.previousLang = this.currentLang;
      this.currentLang = pathLang;
      localStorage.setItem('selectedLang', pathLang);
      this._applyLanguage(pathLang, false);
      this._updateUI(pathLang);
      
      // บันทึก state ให้ครั้งต่อไปมี state
      this._updateHistoryState(pathLang, false);
    }
  }

  _broadcastChange(lang) {
    // BroadcastChannel
    if (typeof BroadcastChannel !== 'undefined') {
      try {
        const bc = new BroadcastChannel('fv-lang');
        bc.postMessage({ 
          lang, 
          url: location.href,
          timestamp: Date.now()
        });
        setTimeout(() => bc.close(), 1000);
      } catch (e) {}
    }
    
    // Custom event
    window.dispatchEvent(new CustomEvent('languageChange', {
      detail: { language: lang, previous: this.previousLang }
    }));
  }

  // ============ UI Components ============
  
  _initUI() {
    this._createDropdown();
    this._updateUI(this.currentLang);
  }

  _createDropdown() {
    // สร้าง dropdown ถ้ายังไม่มี
    if (document.getElementById('language-dropdown')) return;
    
    const btn = document.getElementById('language-button');
    if (!btn) return;
    
    // Style button
    btn.innerHTML = `
      <span class="lang-icon">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M4 5h7M9 3v2c0 4.418-2.239 8-5 8M5 9c0 2.144 2.952 3.908 6.7 4M12 20l4-9 4 9M19.1 18h-6.2"/>
        </svg>
      </span>
      <span class="lang-text"></span>
    `;
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'language-overlay';
    overlay.className = 'lang-overlay';
    overlay.style.cssText = `
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      z-index: 999;
    `;
    overlay.addEventListener('click', () => this._closeDropdown());
    document.body.appendChild(overlay);
    
    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.id = 'language-dropdown';
    dropdown.className = 'lang-dropdown';
    dropdown.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: white;
      border-radius: 12px;
      padding: 16px;
      min-width: 200px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
      z-index: 1000;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    `;
    
    // Populate options
    Object.entries(this.config || {}).forEach(([code, cfg]) => {
      const option = document.createElement('div');
      option.className = 'lang-option';
      option.dataset.lang = code;
      option.textContent = cfg.label || code;
      option.style.cssText = `
        padding: 12px 16px;
        cursor: pointer;
        border-radius: 8px;
        transition: background 0.2s;
      `;
      option.addEventListener('mouseenter', () => {
        option.style.background = '#f3f4f6';
      });
      option.addEventListener('mouseleave', () => {
        option.style.background = '';
      });
      option.addEventListener('click', () => {
        this.selectLanguage(code);
        this._closeDropdown();
      });
      dropdown.appendChild(option);
    });
    
    document.body.appendChild(dropdown);
    
    // Button click
    btn.addEventListener('click', () => this._toggleDropdown());
    
    this.dropdown = dropdown;
    this.overlay = overlay;
  }

  _toggleDropdown() {
    if (this.isDropdownOpen) {
      this._closeDropdown();
    } else {
      this._openDropdown();
    }
  }

  _openDropdown() {
    this.isDropdownOpen = true;
    this.overlay.style.visibility = 'visible';
    this.overlay.style.opacity = '1';
    this.dropdown.style.visibility = 'visible';
    this.dropdown.style.opacity = '1';
    this.dropdown.style.transform = 'translate(-50%, -50%) scale(1)';
    
    // Lock scroll
    this._scrollY = window.scrollY;
    document.body.style.position = 'fixed';
    document.body.style.top = `-${this._scrollY}px`;
    document.body.style.width = '100%';
  }

  _closeDropdown() {
    this.isDropdownOpen = false;
    this.overlay.style.opacity = '0';
    this.dropdown.style.opacity = '0';
    this.dropdown.style.transform = 'translate(-50%, -50%) scale(0.95)';
    
    setTimeout(() => {
      this.overlay.style.visibility = 'hidden';
      this.dropdown.style.visibility = 'hidden';
      
      // Unlock scroll
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      window.scrollTo(0, this._scrollY || 0);
    }, 300);
  }

  _updateUI(lang) {
    const btn = document.getElementById('language-button');
    if (!btn) return;
    
    const cfg = this.config?.[lang];
    const textSpan = btn.querySelector('.lang-text');
    if (textSpan && cfg) {
      textSpan.textContent = cfg.buttonText || cfg.label || lang.toUpperCase();
    }
    
    // Highlight selected
    document.querySelectorAll('.lang-option').forEach(opt => {
      opt.style.background = opt.dataset.lang === lang ? '#e5e7eb' : '';
      opt.style.fontWeight = opt.dataset.lang === lang ? '600' : '';
    });
    
    // Update all internal links to have correct prefix
    this._updateLinks(lang);
  }

  _updateLinks(currentLang) {
    document.querySelectorAll('a[href^="/"]').forEach(a => {
      const href = a.getAttribute('href');
      if (!href || href.match(/^\/(assets|api|static|_next)\//)) return;
      
      // ลบ prefix เก่า
      const cleanHref = href.replace(/^\/[a-z]{2}\b/, '') || '/';
      
      // เพิ่ม prefix ใหม่ถ้าไม่ใช่ en
      const newHref = currentLang === 'en' 
        ? cleanHref 
        : `/${currentLang}${cleanHref === '/' ? '' : cleanHref}`;
      
      if (href !== newHref) {
        a.setAttribute('href', newHref);
      }
    });
  }

  // ============ Mutation Observer ============
  
  _setupMutationObserver() {
    const observer = new MutationObserver((mutations) => {
      let hasNew = false;
      
      mutations.forEach(m => {
        m.addedNodes.forEach(n => {
          if (n.nodeType === 1) {
            if (n.hasAttribute?.('data-translate') || n.querySelector?.('[data-translate]')) {
              hasNew = true;
            }
          }
        });
      });
      
      if (hasNew && this.currentLang !== 'en') {
        clearTimeout(this._debounceTimer);
        this._debounceTimer = setTimeout(() => {
          this._loadLanguageData(this.currentLang).then(data => {
            if (data) this._translateAll(data);
          });
        }, 100);
      }
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
    this.observer = observer;
  }

  // ============ Public API ============
  
  getCurrentLanguage() {
    return this.currentLang;
  }
  
  getPreviousLanguage() {
    return this.previousLang;
  }
  
  getSupportedLanguages() {
    return Object.keys(this.config || {});
  }
  
  destroy() {
    this.observer?.disconnect();
    this.workerPool?.terminate();
    this.dropdown?.remove();
    this.overlay?.remove();
  }
}

// Initialize
const languageManager = new LanguageManager();
window.languageManager = languageManager;

if (typeof module !== 'undefined' && module.exports) {
  module.exports = languageManager;
}
