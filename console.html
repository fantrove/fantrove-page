<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0d1117">
    <title>Fantrove Console Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-primary: #0d1117; --bg-secondary: #161b22; --bg-tertiary: #21262d; --bg-hover: #30363d;
            --border-color: #30363d; --text-primary: #c9d1d9; --text-secondary: #8b949e;
            --accent-blue: #58a6ff; --accent-green: #238636; --accent-yellow: #d29922; --accent-red: #da3633;
            --accent-purple: #8957e5; --accent-cyan: #39c5cf; --accent-orange: #f0883e;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Fira Code', monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom);
        }
        html, body { height: 100%; overflow: hidden; background: var(--bg-primary); color: var(--text-primary); font-family: var(--font-sans); }
        body { display: flex; flex-direction: column; padding-top: var(--safe-top); padding-bottom: var(--safe-bottom); }
        .header { background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .brand { display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 600; }
        .brand-icon { width: 28px; height: 28px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
        .header-actions { display: flex; gap: 6px; }
        .btn { background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 4px; white-space: nowrap; touch-action: manipulation; }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-icon { font-size: 16px; }
        .connection-bar { background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); padding: 8px 16px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .status-indicator { display: flex; align-items: center; gap: 6px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent-green); animation: pulse 2s infinite; flex-shrink: 0; }
        .status-dot.error { background: var(--accent-red); animation: none; }
        .status-dot.offline { background: var(--accent-yellow); animation: none; }
        .status-dot.local { background: var(--accent-blue); animation: none; }
        .status-dot.syncing { background: var(--accent-purple); animation: spin 1s linear infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        @keyframes spin { to { transform: rotate(360deg); } }
        .toolbar { background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); padding: 8px; display: flex; gap: 8px; align-items: center; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-shrink: 0; scrollbar-width: none; }
        .toolbar::-webkit-scrollbar { display: none; }
        .filter-group { display: flex; gap: 4px; flex-shrink: 0; }
        .filter-btn { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); padding: 6px 10px; border-radius: 12px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px; transition: all 0.2s; white-space: nowrap; touch-action: manipulation; }
        .filter-btn:active { transform: scale(0.95); }
        .filter-btn.active { background: var(--bg-tertiary); color: var(--text-primary); }
        .filter-btn[data-level="error"].active { background: rgba(218, 54, 51, 0.2); color: var(--accent-red); border-color: var(--accent-red); }
        .filter-btn[data-level="warn"].active { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); border-color: var(--accent-yellow); }
        .filter-btn[data-level="info"].active { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); border-color: var(--accent-blue); }
        .filter-btn[data-level="log"].active { background: rgba(201, 209, 217, 0.2); color: var(--text-primary); }
        .filter-btn[data-level="debug"].active { background: rgba(137, 87, 229, 0.2); color: var(--accent-purple); border-color: var(--accent-purple); }
        .filter-btn[data-level="success"].active { background: rgba(35, 134, 54, 0.2); color: var(--accent-green); border-color: var(--accent-green); }
        .badge { background: var(--bg-primary); padding: 1px 5px; border-radius: 10px; font-size: 10px; min-width: 16px; text-align: center; }
        .search-box { position: relative; flex-shrink: 0; }
        .search-box input { background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px 6px 32px; border-radius: 12px; font-size: 13px; width: 140px; font-family: inherit; outline: none; }
        .search-box input:focus { border-color: var(--accent-blue); width: 180px; }
        .search-icon { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); font-size: 12px; opacity: 0.5; }
        .console-container { flex: 1; overflow-y: auto; overflow-x: hidden; font-family: var(--font-mono); font-size: 13px; line-height: 1.5; -webkit-overflow-scrolling: touch; padding-bottom: 20px; }
        .console-container::-webkit-scrollbar { width: 6px; }
        .console-container::-webkit-scrollbar-track { background: var(--bg-primary); }
        .console-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        .log-entry { padding: 10px 12px; border-left: 3px solid transparent; display: flex; flex-direction: column; gap: 4px; animation: slideIn 0.2s ease; }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .log-entry:active { background: var(--bg-hover); }
        .log-entry.error { border-left-color: var(--accent-red); background: rgba(218, 54, 51, 0.05); }
        .log-entry.warn { border-left-color: var(--accent-yellow); }
        .log-entry.info { border-left-color: var(--accent-blue); }
        .log-entry.log { border-left-color: var(--text-secondary); }
        .log-entry.debug { border-left-color: var(--accent-purple); }
        .log-entry.success { border-left-color: var(--accent-green); }
        .log-category { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 600; text-transform: uppercase; margin-right: 6px; }
        .log-category.code { background: rgba(218, 54, 51, 0.3); color: #ff7b72; }
        .log-category.network { background: rgba(210, 153, 34, 0.3); color: #e3b341; }
        .log-category.system { background: rgba(88, 166, 255, 0.3); color: #58a6ff; }
        .log-category.api { background: rgba(35, 134, 54, 0.3); color: #7ee787; }
        .log-category.unknown { background: rgba(240, 136, 62, 0.3); color: #f0883e; }
        .log-header { display: flex; align-items: center; gap: 8px; font-size: 11px; color: var(--text-secondary); }
        .log-time { font-family: var(--font-mono); opacity: 0.8; }
        .log-level-badge { text-transform: uppercase; font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 600; }
        .log-level-badge.error { background: rgba(218, 54, 51, 0.2); color: var(--accent-red); }
        .log-level-badge.warn { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); }
        .log-level-badge.info { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
        .log-level-badge.debug { background: rgba(137, 87, 229, 0.2); color: var(--accent-purple); }
        .log-level-badge.success { background: rgba(35, 134, 54, 0.2); color: var(--accent-green); }
        .log-source { color: var(--accent-cyan); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .log-content { color: var(--text-primary); word-break: break-word; white-space: pre-wrap; font-size: 13px; line-height: 1.6; }
        .log-entry.error .log-content { color: #ff7b72; }
        .log-entry.warn .log-content { color: #e3b341; }
        .stack-trace { margin-top: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; font-size: 11px; color: var(--text-secondary); overflow-x: auto; white-space: pre; font-family: var(--font-mono); border-left: 2px solid var(--border-color); }
        .meta-data { margin-top: 4px; padding: 4px 8px; background: var(--bg-primary); border-radius: 4px; font-size: 11px; color: var(--accent-cyan); font-family: var(--font-mono); }
        .sync-status { display: inline-flex; align-items: center; gap: 4px; font-size: 11px; color: var(--text-secondary); }
        .sync-status.syncing::before { content: ''; width: 8px; height: 8px; border: 2px solid var(--accent-blue); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); gap: 16px; padding: 40px 20px; text-align: center; }
        .empty-icon { font-size: 64px; opacity: 0.3; }
        .error-banner { background: rgba(218, 54, 51, 0.1); border: 1px solid var(--accent-red); color: var(--accent-red); padding: 12px 16px; margin: 8px; border-radius: 6px; font-size: 13px; display: none; }
        .error-banner.visible { display: block; }
        .retry-btn { background: var(--accent-blue); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px; }
        .input-section { background: var(--bg-secondary); border-top: 1px solid var(--border-color); padding: 12px; flex-shrink: 0; }
        .input-header { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; justify-content: space-between; }
        .input-wrapper { display: flex; gap: 8px; align-items: flex-start; }
        .input-prompt { color: var(--accent-green); font-family: var(--font-mono); font-size: 16px; font-weight: bold; margin-top: 10px; }
        .console-input { flex: 1; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 12px; border-radius: 8px; font-family: var(--font-mono); font-size: 14px; resize: none; min-height: 44px; max-height: 100px; outline: none; -webkit-appearance: none; }
        .console-input:focus { border-color: var(--accent-blue); }
        .send-btn { background: var(--accent-blue); border: none; color: white; width: 44px; height: 44px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: pointer; flex-shrink: 0; }
        .send-btn:active { transform: scale(0.95); opacity: 0.8; }
        .footer { background: var(--bg-tertiary); border-top: 1px solid var(--border-color); padding: 8px 12px; font-size: 11px; color: var(--text-secondary); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .footer-stats { display: flex; gap: 12px; }
        .stat { display: flex; gap: 4px; align-items: center; }
        .stat-value { color: var(--text-primary); font-weight: 600; }
        .stat-value.error { color: var(--accent-red); }
        .stat-value.warn { color: var(--accent-yellow); }
        .toast { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 12px 24px; border-radius: 8px; font-size: 14px; color: var(--text-primary); z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }
        .sync-indicator { display: inline-flex; align-items: center; gap: 4px; }
        .sync-indicator.syncing { color: var(--accent-purple); }
        @media (min-width: 768px) { .header { padding: 16px 24px; } .brand { font-size: 16px; } .toolbar { padding: 12px 24px; } .filter-btn { padding: 6px 14px; } .search-box input { width: 200px; } .search-box input:focus { width: 280px; } .log-entry { padding: 12px 24px; flex-direction: row; align-items: flex-start; } .log-header { flex-direction: column; min-width: 100px; } .input-section { padding: 16px 24px; } .footer { padding: 10px 24px; } }
    </style>
</head>
<body>
    <div class="header">
        <div class="brand">
            <div class="brand-icon">‚óâ</div>
            <span>Fantrove Console</span>
        </div>
        <div class="header-actions">
            <button class="btn" onclick="consolePro.syncAll()" title="Force Sync All">
                <span class="btn-icon">üîÑ</span>
                <span>Sync</span>
            </button>
            <button class="btn" onclick="consolePro.toggleCapture()" id="capture-btn">
                <span class="btn-icon" id="capture-icon">‚è∏</span>
                <span>Pause</span>
            </button>
            <button class="btn" onclick="consolePro.exportLogs()">
                <span class="btn-icon">üì•</span>
            </button>
            <button class="btn" onclick="consolePro.clear()" style="color: var(--accent-red);">
                <span class="btn-icon">üóë</span>
            </button>
        </div>
    </div>

    <div class="connection-bar">
        <div class="status-indicator">
            <span class="status-dot" id="status-dot"></span>
            <span id="status-text">Initializing...</span>
        </div>
        <div>
            <span class="sync-status" id="sync-status">Loading...</span>
        </div>
    </div>

    <div class="error-banner" id="error-banner">
        ‚ö†Ô∏è <span id="error-message">Connection error</span>
        <button class="retry-btn" onclick="consolePro.retryConnection()">Retry</button>
    </div>

    <div class="toolbar">
        <div class="filter-group">
            <button class="filter-btn active" data-level="all" onclick="consolePro.setFilter('all')">
                All <span class="badge" id="count-all">0</span>
            </button>
        </div>
        <div class="filter-group">
            <button class="filter-btn active" data-level="error" onclick="consolePro.setFilter('error')">
                Errors <span class="badge" id="count-error">0</span>
            </button>
            <button class="filter-btn active" data-level="warn" onclick="consolePro.setFilter('warn')">
                Warnings <span class="badge" id="count-warn">0</span>
            </button>
            <button class="filter-btn active" data-level="info" onclick="consolePro.setFilter('info')">
                Info <span class="badge" id="count-info">0</span>
            </button>
            <button class="filter-btn active" data-level="log" onclick="consolePro.setFilter('log')">
                Logs <span class="badge" id="count-log">0</span>
            </button>
            <button class="filter-btn active" data-level="debug" onclick="consolePro.setFilter('debug')">
                Debug <span class="badge" id="count-debug">0</span>
            </button>
            <button class="filter-btn active" data-level="success" onclick="consolePro.setFilter('success')">
                Success <span class="badge" id="count-success">0</span>
            </button>
        </div>
        <div class="search-box">
            <span class="search-icon">üîç</span>
            <input type="text" id="search-input" placeholder="Search..." oninput="consolePro.search(this.value)">
        </div>
    </div>

    <div class="console-container" id="console-output">
        <div class="empty-state" id="initial-state">
            <div class="empty-icon">‚òÅÔ∏è</div>
            <div class="empty-text">Ready</div>
            <div class="empty-hint">Console is starting...</div>
        </div>
    </div>

    <div class="input-section">
        <div class="input-header">
            <span>JavaScript Console</span>
            <span>30-day retention</span>
        </div>
        <div class="input-wrapper">
            <span class="input-prompt">‚ùØ</span>
            <textarea class="console-input" id="js-input" rows="1" 
                placeholder="Enter command..."
                onkeydown="consolePro.handleInput(event)"
                oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight,100)+'px'"></textarea>
            <button class="send-btn" onclick="consolePro.executeFromButton()">‚ñ∂</button>
        </div>
    </div>

    <div class="footer">
        <div class="footer-stats">
            <span class="stat">Total: <span class="stat-value" id="stat-total">0</span></span>
            <span class="stat">Cloud: <span class="stat-value" id="stat-cloud">0</span></span>
            <span class="stat">Local: <span class="stat-value" id="stat-local">0</span></span>
            <span class="stat">Code: <span class="stat-value error" id="stat-code">0</span></span>
            <span class="stat">Network: <span class="stat-value warn" id="stat-network">0</span></span>
        </div>
        <div id="storage-info">‚òÅÔ∏è Supabase</div>
    </div>

    <script>
        class FantroveConsolePro {
            constructor() {
                this.apiUrl = 'https://fantrove-console-api.nontakorn2600.workers.dev';
                this.logs = [];
                this.pendingLogs = [];
                this.activeFilters = new Set(['error', 'warn', 'info', 'log', 'debug', 'success']);
                this.searchQuery = '';
                this.isCapturing = true;
                this.sessionId = this.getOrCreateSession();
                this.isOnline = navigator.onLine;
                this.isCloudConnected = false;
                this.isSyncing = false;
                this.stats = { code: 0, network: 0, system: 0, api: 0, unknown: 0, cloud: 0, local: 0 };
                this.connectionError = null;
                this.isInitialized = false;
                this.lastSyncTime = 0;
                this.syncInterval = null;
                
                // Patterns ‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° system ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
                this.skipStoragePatterns = [
                    /^Console ready \(Session:/i,
                    /^Restored \d+ logs from local backup/i,
                    /^Loaded \d+ new logs from cloud/i,
                    /^Synced \d+\/\d+ pending logs/i,
                    /^Sync completed:/i,
                    /^Capture (resumed|paused)/i,
                    /^Display cleared/i,
                    /^Exported$/i,
                    /^Reconnected successfully$/i,
                    /^Force sync completed/i,
                    /^Synced \d+ total logs/i
                ];
                
                this.init();
            }

            getOrCreateSession() {
                const urlParams = new URLSearchParams(window.location.search);
                const sessionFromUrl = urlParams.get('session');
                if (sessionFromUrl) {
                    localStorage.setItem('fantrove_session_id', sessionFromUrl);
                    return sessionFromUrl;
                }
                let session = localStorage.getItem('fantrove_session_id');
                if (!session) {
                    session = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('fantrove_session_id', session);
                }
                return session;
            }

            init() {
                this.setupNetworkListeners();
                this.setupSmartErrorCapture();
                this.setupAPIMessageHandling();
                this.setupStorageSync();
                this.updateConnectionStatus('local');
                this.isInitialized = true;
                
                // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡πÅ‡∏´‡∏•‡πà‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
                this.loadAllSources();
                
                // ‡πÉ‡∏ä‡πâ skipStorage = true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                this.system('Console ready (Session: ' + this.sessionId.substring(0, 8) + ')', null, true);
                
                // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö Real-time Sync
                this.startRealTimeSync();
            }

            // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡πÅ‡∏´‡∏•‡πà‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
            async loadAllSources() {
                this.setSyncStatus(true, 'Loading data...');
                
                const promises = [];
                
                // ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Local Backup
                promises.push(this.loadFromLocalBackup());
                
                // ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Cloud ‡∏ñ‡πâ‡∏≤ Online
                if (this.isOnline) {
                    promises.push(this.loadLogsFromCloud().catch(err => {
                        console.warn('Cloud load failed:', err);
                        return [];
                    }));
                }
                
                await Promise.all(promises);
                
                // ‡∏£‡∏ß‡∏°‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                this.mergeAndSortLogs();
                this.refreshDisplay();
                this.updateStats();
                this.setSyncStatus(false);
            }

            // ‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡πÅ‡∏´‡∏•‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á
            mergeAndSortLogs() {
                // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ ID ‡∏´‡∏£‡∏∑‡∏≠ timestamp + message ‡πÄ‡∏õ‡πá‡∏ô key
                const seen = new Set();
                const uniqueLogs = [];
                
                // ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° timestamp ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô
                this.logs.sort((a, b) => b.timestamp - a.timestamp);
                
                for (const log of this.logs) {
                    const key = log.id || `${log.timestamp}-${log.message}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueLogs.push(log);
                    }
                }
                
                this.logs = uniqueLogs.slice(0, 1000); // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 1000 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
            }

            async connectToCloud() {
                this.updateConnectionStatus('loading');
                
                try {
                    await this.loadLogsFromCloud();
                    this.isCloudConnected = true;
                    this.updateConnectionStatus('connected');
                    this.hideError();
                } catch (error) {
                    this.isCloudConnected = false;
                    this.updateConnectionStatus('local');
                    throw error;
                }
            }

            async retryConnection() {
                this.hideError();
                try {
                    await this.connectToCloud();
                    this.showToast('Reconnected successfully');
                } catch (error) {
                    this.showError('Still cannot connect to cloud');
                }
            }

            // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Cloud ‡πÉ‡∏´‡πâ‡∏î‡∏∂‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°
            async loadLogsFromCloud() {
                if (!this.isOnline) {
                    throw new Error('Offline');
                }

                const healthController = new AbortController();
                const healthTimeout = setTimeout(() => healthController.abort(), 5000);
                
                let healthCheck;
                try {
                    healthCheck = await fetch(`${this.apiUrl}/health`, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        mode: 'cors',
                        credentials: 'omit',
                        signal: healthController.signal
                    });
                } catch (err) {
                    clearTimeout(healthTimeout);
                    throw new Error('Health check failed');
                }
                clearTimeout(healthTimeout);

                if (!healthCheck || !healthCheck.ok) {
                    throw new Error('Cannot reach API server');
                }

                // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å Cloud (‡πÄ‡∏û‡∏¥‡πà‡∏° limit ‡πÄ‡∏õ‡πá‡∏ô 1000)
                const logsController = new AbortController();
                const logsTimeout = setTimeout(() => logsController.abort(), 10000);
                
                let response;
                try {
                    response = await fetch(
                        `${this.apiUrl}/logs?session=${this.sessionId}&limit=1000`,
                        {
                            method: 'GET',
                            headers: { 'Accept': 'application/json' },
                            mode: 'cors',
                            credentials: 'omit',
                            signal: logsController.signal
                        }
                    );
                } catch (err) {
                    clearTimeout(logsTimeout);
                    throw new Error('Logs fetch failed');
                }
                clearTimeout(logsTimeout);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const logs = await response.json();
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Cloud ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏†‡∏≤‡∏¢‡πÉ‡∏ô
                const cloudLogs = logs.map(log => ({
                    id: log.id,
                    level: log.level || 'info',
                    category: log.category || 'unknown',
                    message: log.message || '',
                    source: log.source || 'Cloud',
                    meta: log.meta || {},
                    stackTrace: log.stack_trace,
                    timestamp: new Date(log.created_at).getTime(),
                    fromCloud: true // Ê†áËÆ∞‡∏ß‡πà‡∏≤‡∏°‡∏≤‡∏à‡∏≤‡∏Å Cloud
                }));
                
                // ‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
                this.logs = [...this.logs, ...cloudLogs];
                
                // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
                this.stats.cloud = cloudLogs.length;
                
                if (cloudLogs.length > 0) {
                    this.system(`Loaded ${cloudLogs.length} logs from cloud`, null, true);
                }
                
                return cloudLogs;
            }

            async saveLogToCloud(log) {
                // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
                if (this.shouldSkipStorage(log)) {
                    return { skipped: true };
                }

                if (!this.isOnline || !this.isCloudConnected) {
                    this.pendingLogs.push(log);
                    this.saveToLocalBackup(log);
                    return { queued: true };
                }

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000);

                try {
                    const payload = {
                        session_id: this.sessionId,
                        level: log.level,
                        category: log.category || 'system',
                        message: log.message,
                        source: log.source,
                        meta: log.meta || {},
                        stack_trace: log.stackTrace,
                        user_agent: navigator.userAgent,
                        url: location.href
                    };

                    const response = await fetch(`${this.apiUrl}/logs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        mode: 'cors',
                        credentials: 'omit',
                        signal: controller.signal,
                        keepalive: true
                    });

                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ID ‡∏à‡∏≤‡∏Å Cloud
                    if (result.id && !log.id) {
                        log.id = result.id;
                        log.fromCloud = true;
                    }
                    
                    return result;
                    
                } catch (error) {
                    clearTimeout(timeout);
                    this.pendingLogs.push(log);
                    this.saveToLocalBackup(log);
                    
                    if (this.isCloudConnected) {
                        this.showError('Sync failed. Logs queued for retry.');
                        this.isCloudConnected = false;
                        this.updateConnectionStatus('local');
                    }
                    
                    return { error: error.message, queued: true };
                }
            }

            // ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            async syncPendingLogs() {
                if (this.pendingLogs.length === 0 || !this.isOnline || this.isSyncing) {
                    return;
                }
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API ‡∏Å‡πà‡∏≠‡∏ô
                const controller = new AbortController();
                const t = setTimeout(() => controller.abort(), 3000);
                
                try {
                    const health = await fetch(`${this.apiUrl}/health`, { 
                        method: 'GET',
                        mode: 'cors',
                        credentials: 'omit',
                        signal: controller.signal
                    });
                    if (!health.ok) throw new Error('API unavailable');
                } catch (e) {
                    clearTimeout(t);
                    return;
                }
                clearTimeout(t);

                this.isSyncing = true;
                this.setSyncStatus(true, `Syncing ${this.pendingLogs.length}...`);
                
                const batch = this.pendingLogs.splice(0, 50);
                const batchController = new AbortController();
                const batchTimeout = setTimeout(() => batchController.abort(), 10000);

                try {
                    const response = await fetch(`${this.apiUrl}/logs/batch`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ logs: batch.map(log => ({
                            session_id: this.sessionId,
                            level: log.level,
                            category: log.category || 'system',
                            message: log.message,
                            source: log.source,
                            meta: log.meta || {},
                            stack_trace: log.stackTrace,
                            user_agent: navigator.userAgent,
                            url: location.href
                        }))}),
                        mode: 'cors',
                        credentials: 'omit',
                        signal: batchController.signal
                    });

                    clearTimeout(batchTimeout);

                    if (response.ok) {
                        const result = await response.json();
                        this.isCloudConnected = true;
                        this.hideError();
                        
                        const saved = result.saved || result.successful || 0;
                        const failed = result.failed || 0;
                        const total = result.total || batch.length;
                        
                        if (saved > 0) {
                            this.system(`Synced ${saved}/${total} pending logs${failed > 0 ? ` (${failed} failed)` : ''}`, null, true);
                        }
                        
                        this.removeFromLocalBackup(saved);
                        
                        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Cloud ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ID
                        await this.loadLogsFromCloud();
                        this.mergeAndSortLogs();
                        this.refreshDisplay();
                        this.updateStats();
                    } else {
                        this.pendingLogs.unshift(...batch);
                    }
                } catch (error) {
                    clearTimeout(batchTimeout);
                    this.pendingLogs.unshift(...batch);
                } finally {
                    this.isSyncing = false;
                    this.setSyncStatus(false);
                }
            }

            // Force Sync ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            async syncAll() {
                this.setSyncStatus(true, 'Full sync...');
                
                // 1. ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå pending logs ‡∏Å‡πà‡∏≠‡∏ô
                await this.syncPendingLogs();
                
                // 2. ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Cloud
                try {
                    await this.loadLogsFromCloud();
                } catch (e) {
                    console.warn('Cloud sync failed:', e);
                }
                
                // 3. ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Local ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                await this.loadFromLocalBackup();
                
                // 4. ‡∏£‡∏ß‡∏°‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á
                this.mergeAndSortLogs();
                this.refreshDisplay();
                this.updateStats();
                
                this.setSyncStatus(false);
                this.showToast(`Synced ${this.logs.length} total logs`);
            }

            // Real-time Sync ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
            startRealTimeSync() {
                // Sync ‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                this.syncInterval = setInterval(() => {
                    if (!document.hidden && this.isOnline) {
                        this.syncPendingLogs();
                        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Cloud ‡∏ó‡∏∏‡∏Å 2 ‡∏ô‡∏≤‡∏ó‡∏µ
                        if (Date.now() - this.lastSyncTime > 120000) {
                            this.loadLogsFromCloud().then(() => {
                                this.mergeAndSortLogs();
                                this.refreshDisplay();
                                this.updateStats();
                            }).catch(() => {});
                            this.lastSyncTime = Date.now();
                        }
                    }
                }, 30000);

                // Sync ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.syncPendingLogs();
                    }
                });

                // Sync ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤ Online
                window.addEventListener('online', () => {
                    setTimeout(() => this.syncAll(), 1000);
                });
            }

            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.updateConnectionStatus('local');
                });
                
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.isCloudConnected = false;
                    this.updateConnectionStatus('offline');
                });
            }

            // ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Local Backup ‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å
            async loadFromLocalBackup() {
                try {
                    const backup = JSON.parse(localStorage.getItem('fantrove_backup') || '[]');
                    const recent = backup.filter(l => Date.now() - (l._savedAt || 0) < 86400000);
                    
                    if (recent.length > 0) {
                        // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö
                        const localLogs = recent.map(log => ({
                            ...log,
                            fromLocal: true, // Ê†áËÆ∞‡∏ß‡πà‡∏≤‡∏°‡∏≤‡∏à‡∏≤‡∏Å Local
                            id: log.id || `local_${Date.now()}_${Math.random()}`
                        }));
                        
                        // ‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å
                        this.logs = [...this.logs, ...localLogs];
                        this.pendingLogs.push(...localLogs.filter(l => !l.fromCloud));
                        
                        this.stats.local = localLogs.length;
                        
                        // ‡πÉ‡∏ä‡πâ skipStorage = true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ
                        this.system(`Restored ${recent.length} logs from local backup`, null, true);
                    }
                    
                    // ‡∏•‡πâ‡∏≤‡∏á backup ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß
                    const validBackup = backup.filter(l => Date.now() - (l._savedAt || 0) < 86400000);
                    localStorage.setItem('fantrove_backup', JSON.stringify(validBackup));
                    
                } catch (e) {
                    console.error('Load backup failed:', e);
                }
            }

            saveToLocalBackup(log) {
                // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
                if (this.shouldSkipStorage(log)) {
                    return;
                }
                
                try {
                    const backup = JSON.parse(localStorage.getItem('fantrove_backup') || '[]');
                    backup.push({ ...log, _savedAt: Date.now() });
                    if (backup.length > 200) backup.shift(); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 200 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
                    localStorage.setItem('fantrove_backup', JSON.stringify(backup));
                } catch (e) {}
            }

            removeFromLocalBackup(count) {
                try {
                    const backup = JSON.parse(localStorage.getItem('fantrove_backup') || '[]');
                    const remaining = backup.slice(count);
                    localStorage.setItem('fantrove_backup', JSON.stringify(remaining));
                } catch (e) {}
            }

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å‡πÅ‡∏ó‡πá‡∏ö‡∏≠‡∏∑‡πà‡∏ô
            setupStorageSync() {
                window.addEventListener('storage', (e) => {
                    if (e.key === 'fantrove_backup' && e.newValue) {
                        try {
                            const data = JSON.parse(e.newValue);
                            if (Array.isArray(data) && data.length > 0) {
                                // ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡πÅ‡∏ó‡πá‡∏ö‡∏≠‡∏∑‡πà‡∏ô
                                const newLogs = data.filter(log => 
                                    !this.logs.some(existing => existing.id === log.id)
                                );
                                if (newLogs.length > 0) {
                                    this.logs.push(...newLogs);
                                    this.mergeAndSortLogs();
                                    this.refreshDisplay();
                                    this.updateStats();
                                }
                            }
                        } catch (err) {}
                    }
                });
            }

            /**
             * ‡πÄ‡∏û‡∏¥‡πà‡∏° log entry
             * @param {Object} log - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• log
             * @param {boolean} saveToCloud - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á cloud ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
             * @param {boolean} skipStorage - ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (cloud + local) ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
             */
            async addLog(log, saveToCloud = true, skipStorage = false) {
                log.id = log.id || (Date.now() + Math.random()).toString();
                log.timestamp = log.timestamp || Date.now();
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° system ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                const shouldSkipStorage = skipStorage || this.shouldSkipStorage(log);
                
                this.logs.push(log);
                if (this.logs.length > 1000) this.logs.shift();
                
                if (this.isCapturing && this.shouldDisplay(log)) {
                    this.renderLog(log);
                }
                
                this.updateStats();
                
                if (this.stats[log.category] !== undefined) {
                    this.stats[log.category]++;
                } else {
                    this.stats.unknown++;
                }
                
                // ‡∏ñ‡πâ‡∏≤ skipStorage ‡πÄ‡∏õ‡πá‡∏ô true ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á cloud ‡πÅ‡∏•‡∏∞ local backup
                if (!shouldSkipStorage && saveToCloud && this.isInitialized) {
                    this.saveLogToCloud(log).catch(() => {});
                }
            }

            /**
             * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏ß‡∏£‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
             */
            shouldSkipStorage(log) {
                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà system log ‡πÉ‡∏´‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
                if (log.category !== 'system' && log.source !== 'System') {
                    return false;
                }
                
                const message = log.message || '';
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏±‡∏ö patterns ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ
                return this.skipStoragePatterns.some(pattern => pattern.test(message));
            }

            shouldDisplay(log) {
                if (!this.activeFilters.has(log.level)) return false;
                if (!this.searchQuery) return true;
                const query = this.searchQuery.toLowerCase();
                return (log.message || '').toLowerCase().includes(query) ||
                       (log.source || '').toLowerCase().includes(query) ||
                       (log.category || '').toLowerCase().includes(query);
            }

            renderLog(log, animate = true) {
                const output = document.getElementById('console-output');
                const emptyState = output.querySelector('.empty-state');
                if (emptyState) emptyState.remove();

                const entry = document.createElement('div');
                entry.className = `log-entry ${log.level}`;
                if (!animate) entry.style.animation = 'none';
                
                const time = new Date(log.timestamp).toLocaleTimeString('en-GB', {
                    hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
                });

                const levelColors = { 
                    error: 'error', warn: 'warn', info: 'info', 
                    debug: 'debug', log: '', success: 'success' 
                };
                
                // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å
                const categoryClass = log.category || 'unknown';
                const categoryLabel = log.category || 'unknown';
                
                let stackHtml = log.stackTrace ? `<div class="stack-trace">${this.escapeHtml(log.stackTrace)}</div>` : '';
                
                let metaHtml = '';
                if (log.meta && Object.keys(log.meta).length > 0) {
                    const metaStr = Object.entries(log.meta)
                        .filter(([k, v]) => v !== undefined && v !== null)
                        .map(([k, v]) => `${k}: ${v}`)
                        .join(', ');
                    if (metaStr) metaHtml = `<div class="meta-data">${this.escapeHtml(metaStr)}</div>`;
                }

                // ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Cloud/Local)
                const sourceIndicator = log.fromCloud ? '‚òÅÔ∏è' : (log.fromLocal ? 'üíæ' : '');

                entry.innerHTML = `
                    <div class="log-header">
                        <span class="log-time">${time}</span>
                        <span class="log-level-badge ${levelColors[log.level] || ''}">${log.level}</span>
                        <span class="log-category ${categoryClass}">${categoryLabel}</span>
                        <span class="log-source">${log.source || 'System'} ${sourceIndicator}</span>
                    </div>
                    <div class="log-content">${this.escapeHtml(log.message)}</div>
                    ${metaHtml}
                    ${stackHtml}
                `;

                output.appendChild(entry);
                
                const isNearBottom = output.scrollHeight - output.scrollTop - output.clientHeight < 100;
                if (isNearBottom) output.scrollTop = output.scrollHeight;
            }

            escapeHtml(text) {
                if (typeof text !== 'string') text = String(text);
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            stringify(arg) {
                if (arg === null) return 'null';
                if (arg === undefined) return 'undefined';
                if (typeof arg === 'object') {
                    try { return JSON.stringify(arg); } catch (e) { return '[Object]'; }
                }
                return String(arg);
            }

            setupSmartErrorCapture() {
                window.addEventListener('error', (event) => {
                    if (this.isNoiseError(event)) return;
                    this.captureError({
                        type: 'code', category: 'code', message: event.message,
                        filename: event.filename, lineno: event.lineno,
                        stack: event.error?.stack, isUserCode: this.isUserCode(event.filename)
                    });
                });

                window.addEventListener('unhandledrejection', (event) => {
                    if (this.isNoisePromise(event.reason)) return;
                    this.captureError({
                        type: 'promise', category: 'code',
                        message: event.reason?.message || String(event.reason),
                        stack: event.reason?.stack, isUserCode: true
                    });
                });

                this.setupSmartNetworkCapture();

                const originalError = console.error;
                console.error = (...args) => {
                    originalError.apply(console, args);
                    if (!this.isCapturing) return;
                    const message = args.map(a => this.stringify(a)).join(' ');
                    if (this.isNoiseMessage(message)) return;
                    const error = args.find(a => a instanceof Error);
                    if (error) {
                        this.captureError({
                            type: 'console', category: 'code', message: message,
                            stack: error.stack, isUserCode: true
                        });
                    }
                };
            }

            isNoiseError(event) {
                const noise = ['ResizeObserver loop', 'Script error.', 'The operation was aborted', 'The user aborted a request'];
                return noise.some(n => event.message?.includes(n));
            }

            isNoisePromise(reason) {
                if (!reason) return true;
                const msg = String(reason.message || reason).toLowerCase();
                return msg.includes('resizeobserver') || msg.includes('abort') || msg.includes('cancel');
            }

            isNoiseMessage(msg) {
                const noise = ['webpack', 'hot module', 'HMR', '[Vue warn]', '[WDS]', 'ResizeObserver'];
                return noise.some(n => msg.includes(n));
            }

            isUserCode(filename) {
                if (!filename) return true;
                const thirdParty = ['node_modules', 'vendor', 'webpack', 'react-dom', 'vue.runtime'];
                return !thirdParty.some(p => filename.includes(p));
            }

            setupSmartNetworkCapture() {
                const originalFetch = window.fetch;
                window.fetch = async function(...args) {
                    const url = args[0];
                    try {
                        const response = await originalFetch.apply(window, args);
                        if (response.status >= 500) {
                            if (window.consolePro && typeof window.consolePro.captureError === 'function') {
                                window.consolePro.captureError({
                                    type: 'http', category: 'network',
                                    message: `Server Error ${response.status}: ${response.statusText}`,
                                    url: url, status: response.status, critical: true
                                });
                            }
                        }
                        return response;
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            if (window.consolePro && typeof window.consolePro.captureError === 'function') {
                                window.consolePro.captureError({
                                    type: 'network', category: 'network',
                                    message: `Network Failed: ${error.message}`,
                                    url: url, error: error.name, critical: true
                                });
                            }
                        }
                        throw error;
                    }
                };
            }

            captureError(errorData) {
                const log = {
                    level: errorData.critical ? 'error' : (errorData.category === 'network' ? 'warn' : 'error'),
                    message: this.formatErrorMessage(errorData),
                    source: errorData.filename || errorData.url || 'System',
                    category: errorData.category || 'system',
                    stackTrace: errorData.stack,
                    meta: {
                        type: errorData.type, line: errorData.lineno,
                        column: errorData.colno, status: errorData.status,
                        isUserCode: errorData.isUserCode
                    },
                    timestamp: Date.now()
                };
                this.addLog(log);
            }

            formatErrorMessage(data) {
                let msg = '';
                const labels = { code: '[CODE]', network: '[NETWORK]', system: '[SYSTEM]', api: '[API]' };
                msg += (labels[data.category] || '[ERROR]') + ' ';
                
                if (data.type === 'code' && data.filename) {
                    const file = data.filename.split('/').pop();
                    msg += `${data.message} (${file}:${data.lineno || 0})`;
                } else if (data.type === 'network' && data.url) {
                    const urlObj = new URL(data.url, location.href);
                    msg += `${data.message} ‚Üí ${urlObj.pathname}`;
                } else {
                    msg += data.message;
                }
                return msg;
            }

            setupAPIMessageHandling() {
                window.addEventListener('message', (e) => {
                    if (e.data?.type === 'FANTROVE_LOG') this.receiveAPILog(e.data.payload);
                });

                window.addEventListener('storage', (e) => {
                    if (e.key === 'fantrove_broadcast') {
                        try {
                            const data = JSON.parse(e.newValue);
                            if (data && !data._local) this.receiveAPILog(data);
                        } catch (err) {}
                    }
                });

                if (typeof BroadcastChannel !== 'undefined') {
                    this.channel = new BroadcastChannel('fantrove_console');
                    this.channel.onmessage = (e) => {
                        if (e.data?.type === 'FANTROVE_LOG') this.receiveAPILog(e.data.payload);
                    };
                }
            }

            receiveAPILog(data) {
                const log = {
                    level: data.level || 'info', message: data.message,
                    source: data.source || 'API', category: 'api',
                    meta: data.meta || null, stackTrace: data.stack,
                    timestamp: Date.now()
                };
                this.addLog(log, false);
            }

            setFilter(level) {
                if (level === 'all') {
                    const allActive = this.activeFilters.size === 6;
                    if (allActive) {
                        this.activeFilters.clear();
                        document.querySelectorAll('.filter-btn[data-level]').forEach(btn => btn.classList.remove('active'));
                    } else {
                        ['error', 'warn', 'info', 'log', 'debug', 'success'].forEach(l => this.activeFilters.add(l));
                        document.querySelectorAll('.filter-btn[data-level]').forEach(btn => btn.classList.add('active'));
                    }
                } else {
                    const btn = document.querySelector(`[data-level="${level}"]`);
                    if (this.activeFilters.has(level)) {
                        this.activeFilters.delete(level);
                        btn.classList.remove('active');
                    } else {
                        this.activeFilters.add(level);
                        btn.classList.add('active');
                    }
                }
                this.refreshDisplay();
            }

            search(query) {
                this.searchQuery = query;
                this.refreshDisplay();
            }

            refreshDisplay() {
                const output = document.getElementById('console-output');
                output.innerHTML = '';
                
                const toShow = this.logs.filter(log => this.shouldDisplay(log));
                
                if (toShow.length === 0) {
                    output.innerHTML = `<div class="empty-state"><div class="empty-icon">üîç</div><div class="empty-text">No matching logs</div></div>`;
                } else {
                    toShow.forEach(log => this.renderLog(log, false));
                }
            }

            handleInput(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.executeFromButton();
                }
            }

            executeFromButton() {
                const input = document.getElementById('js-input');
                const code = input.value.trim();
                if (code) {
                    this.system('> ' + code);
                    try {
                        const result = eval(code);
                        if (result !== undefined) this.system('< ' + result);
                    } catch (err) {
                        this.error('‚úñ ' + err.message);
                    }
                    input.value = '';
                    input.style.height = 'auto';
                }
            }

            toggleCapture() {
                this.isCapturing = !this.isCapturing;
                const btn = document.getElementById('capture-btn');
                if (this.isCapturing) {
                    btn.innerHTML = '<span class="btn-icon">‚è∏</span><span>Pause</span>';
                    this.system('Capture resumed', null, true);
                } else {
                    btn.innerHTML = '<span class="btn-icon">‚ñ∂</span><span>Resume</span>';
                    this.warn('Capture paused', null, true);
                }
            }

            async clear() {
                if (confirm('Clear all logs?')) {
                    this.logs = [];
                    this.pendingLogs = [];
                    this.stats = { code: 0, network: 0, system: 0, api: 0, unknown: 0, cloud: 0, local: 0 };
                    this.refreshDisplay();
                    this.updateStats();
                    this.showToast('Display cleared');
                }
            }

            exportLogs() {
                const data = {
                    exported: new Date().toISOString(),
                    session: this.sessionId,
                    count: this.logs.length,
                    stats: this.stats,
                    logs: this.logs
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fantrove-logs-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                this.showToast('Exported');
            }

            updateStats() {
                const counts = { all: this.logs.length, error: 0, warn: 0, info: 0, log: 0, debug: 0, success: 0 };
                const categories = { code: 0, network: 0, system: 0, api: 0, unknown: 0 };
                let cloudCount = 0;
                let localCount = 0;
                
                this.logs.forEach(log => { 
                    if (counts[log.level] !== undefined) counts[log.level]++;
                    if (categories[log.category] !== undefined) {
                        categories[log.category]++;
                    } else {
                        categories.unknown++;
                    }
                    if (log.fromCloud) cloudCount++;
                    if (log.fromLocal) localCount++;
                });
                
                Object.keys(counts).forEach(key => {
                    const el = document.getElementById(`count-${key}`);
                    if (el) el.textContent = counts[key];
                });

                document.getElementById('stat-total').textContent = counts.all;
                document.getElementById('stat-cloud').textContent = cloudCount;
                document.getElementById('stat-local').textContent = localCount;
                document.getElementById('stat-code').textContent = categories.code;
                document.getElementById('stat-network').textContent = categories.network;
                
                this.stats = { ...this.stats, ...categories, cloud: cloudCount, local: localCount };
            }

            updateConnectionStatus(status) {
                const dot = document.getElementById('status-dot');
                const text = document.getElementById('status-text');
                
                const styles = {
                    loading: { color: 'var(--accent-yellow)', text: 'Connecting...', dot: '' },
                    connected: { color: 'var(--accent-green)', text: 'Cloud Connected', dot: '' },
                    local: { color: 'var(--accent-blue)', text: 'Local Mode', dot: 'local' },
                    offline: { color: 'var(--accent-yellow)', text: 'Offline', dot: 'offline' },
                    syncing: { color: 'var(--accent-purple)', text: 'Syncing...', dot: 'syncing' }
                };
                
                const style = styles[status] || styles.local;
                dot.className = 'status-dot ' + style.dot;
                text.textContent = style.text;
                text.style.color = style.color;
            }

            setSyncStatus(syncing, message = '') {
                const status = document.getElementById('sync-status');
                if (syncing) {
                    status.textContent = message || 'Syncing...';
                    status.className = 'sync-status syncing';
                } else {
                    const pending = this.pendingLogs.length;
                    const backup = JSON.parse(localStorage.getItem('fantrove_backup') || '[]').length;
                    const total = pending + backup;
                    
                    if (!this.isOnline) status.textContent = `${total} queued (offline)`;
                    else if (!this.isCloudConnected) status.textContent = `${total} pending`;
                    else status.textContent = total > 0 ? `${total} syncing...` : 'Synced';
                    
                    status.className = 'sync-status';
                }
            }

            showError(message) {
                this.connectionError = message;
                document.getElementById('error-message').textContent = message;
                document.getElementById('error-banner').classList.add('visible');
            }

            hideError() {
                this.connectionError = null;
                document.getElementById('error-banner').classList.remove('visible');
            }

            showToast(msg) {
                const existing = document.querySelector('.toast');
                if (existing) existing.remove();
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = msg;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            }

            // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á method ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå skipStorage
            log(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'log', message: msg, source: 'Console', category: 'api', meta, timestamp: Date.now() }, true, skipStorage); 
            }
            
            info(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'info', message: msg, source: 'Console', category: 'api', meta, timestamp: Date.now() }, true, skipStorage); 
            }
            
            warn(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'warn', message: msg, source: 'Console', category: 'api', meta, timestamp: Date.now() }, true, skipStorage); 
            }
            
            error(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'error', message: msg, source: 'Console', category: 'api', meta, timestamp: Date.now() }, true, skipStorage); 
            }
            
            debug(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'debug', message: msg, source: 'Console', category: 'api', meta, timestamp: Date.now() }, true, skipStorage); 
            }
            
            system(msg, meta, skipStorage = false) { 
                this.addLog({ level: 'info', message: msg, source: 'System', category: 'system', timestamp: Date.now() }, true, skipStorage); 
            }
        }

        window.consolePro = new FantroveConsolePro();

        window.FantroveConsole = {
            log: (m, meta) => consolePro.log(m, meta),
            info: (m, meta) => consolePro.info(m, meta),
            warn: (m, meta) => consolePro.warn(m, meta),
            error: (m, meta) => consolePro.error(m, meta),
            debug: (m, meta) => consolePro.debug(m, meta),
            success: (m, meta) => consolePro.addLog({ level: 'success', message: m, source: 'API', category: 'api', meta, timestamp: Date.now() })
        };
    </script>
</body>
</html>
